public Future<JsonObject> executeQuery(String sql) {
    requireNonNull(sql, SQL_IS_REQUIRED_AND_MISSING);

    Promise<JsonObject> promise = Promise.promise();
    this.getPostgresConn(UUID.randomUUID().toString())
        .onSuccess(
            conn ->
                conn.preparedQuery(sql)
                    .execute(
                        ar -> {
                          conn.close();
                          if (ar.succeeded()) {

                            if (ar.result().size() > 0 && ar.result().iterator().hasNext()) {
                              promise.complete(ar.result().iterator().next().toJson());
                              LOGGER.debug(
                                  "Number of rows fetch from PG to re-process: {} ",
                                  ar.result().size());
                            } else {
                              LOGGER.debug("No data from PG to re-process: {}", ar.result().size());
                              promise.complete();
                            }
                          } else {

                            LOGGER.error(
                                "Error while executing PG query. Cause: {}",
                                ar.cause().getMessage(),
                                ar.cause());
                            promise.fail(ar.cause());
                          }
                        }))
        .onFailure(
            error -> {
              LOGGER.error(
                  "Error while getting connections from PG DB executeQuery(). Cause: {} {} {}",
                  error.getMessage(),
                  error,
                  sql);
              promise.fail(error);
            });
    return promise.future();
  }

private Future<SqlConnection> getConnectionFromPool(String correlationId) {
    Promise<SqlConnection> sqlConnectionPromise = Promise.promise();
    db = isPrimary ? PRIMARY_DB : SECONDARY_DB;
    LOGGER.info("CorrelationId: {}, in getConnectionFromPool", correlationId);
    this.jdbcPool1
        .getConnection()
        .onSuccess(
            sqlConn -> {
              LOGGER.info("CorrelationId: {}, Connection to {} established", correlationId, db);
              isSqlConnectionAvailable = true;
              sqlConnectionPromise.complete(sqlConn);
            })
        .onFailure(
            err -> {
              isSqlConnectionAvailable = false;
              LOGGER.error(
                  "CorrelationId: {}: Failed to connect to  {}, cause: {}, stacktrace : {}",
                  correlationId,
                  db,
                  err.getLocalizedMessage(),
                  err.getCause());
              sqlConnectionPromise.fail(err);
            });

    return sqlConnectionPromise.future();
  }
public Future<SqlConnection> getPostgresConn(String correlationId) {
    Promise<SqlConnection> sqlConnectionPromise = Promise.promise();
    LOGGER.info(
        "CorrelationId: {} , CurrentPool: {} , isSwitchInProgress: {}, isSqlConnectionAvailable: {} ",
        correlationId,
        db,
        isSwitchInProgress,
        isSqlConnectionAvailable);

    if (isSqlConnectionAvailable) {
      LOGGER.info("CorrelationId: {}, connection available. get one", correlationId);
      getConnectionFromPool(correlationId)
          .onSuccess(
              conn -> {
                isSqlConnectionAvailable = true;
                LOGGER.info(
                    "CorrelationId: {} : connection successful from existing {} pool",
                    correlationId,
                    db);
                sqlConnectionPromise.complete(conn);
              })
          .onFailure(err -> reAttemptConnection(correlationId, sqlConnectionPromise, err));
    } else {
      LOGGER.info(
          "CorrelationId: {} : connection not available. create pool and get one", correlationId);
      createPoolAndGetConnection(correlationId)
          .onSuccess(
              conn -> {
                LOGGER.info(
                    "CorrelationId: {} : connection successful from new {} pool",
                    correlationId,
                    db);
                isSqlConnectionAvailable = true;
                sqlConnectionPromise.complete(conn);
              })
          .onFailure(
              err -> {
                LOGGER.error("CorrelationId: {} : connection failed", correlationId);
                isSqlConnectionAvailable = false;
                sqlConnectionPromise.fail(err);
              });
    }

    return sqlConnectionPromise.future();
  }

private Future<SqlConnection> createPoolAndGetConnection(String correlationId) {

    Promise<SqlConnection> sqlConnectionPromise = Promise.promise();
    AtomicReference<PgConnectOptions> connectOptions = new AtomicReference<>();
    if (this.jdbcPool1 == null) {
      LOGGER.info("CorrelationId: {}, creating new PG pool", correlationId);
      JsonObject pgConfig = this.config.getJsonObject(AppConstants.CONFIG_POSTGRES_CONFIG);
      connectOptions.set(getConnectOptions(isPrimary));
      PoolOptions poolOptions =
          new PoolOptions()
              .setMaxSize(pgConfig.getInteger("pg-max-pool-size"))
              .setMaxWaitQueueSize(pgConfig.getInteger("MaxWaitQueueSize"))
              .setConnectionTimeout(pgConfig.getInteger("pg-connect-timeout-ms"))
              .setConnectionTimeoutUnit(TimeUnit.MILLISECONDS)
              .setIdleTimeout(pgConfig.getInteger("pg-idle-timeout"))
              .setIdleTimeoutUnit(TimeUnit.SECONDS);

      this.jdbcPool1 = PgPool.pool(vertx, connectOptions.get(), poolOptions);
      this.primarySwitchInterval = pgConfig.getInteger("primarySwitchInterval");
      this.connectionReAttemptDelay = pgConfig.getInteger("connectionReAttemptDelay");
    }
    db = isPrimary ? PRIMARY_DB : SECONDARY_DB;

    if (isSwitchInProgress) {
      LOGGER.info("CorrelationId: {}, switch in progress.. add to wait list", correlationId);
      waitingList.put(correlationId, sqlConnectionPromise);
    } else {
      Future<SqlConnection> sqlConn =
          getConnectionFromPool(correlationId)
              .onFailure(
                  ex -> {
                    reAttemptConnection(correlationId, sqlConnectionPromise, ex);
                  })
              .onSuccess(
                  conn1 -> {
                    isSqlConnectionAvailable = true;
                    sqlConnectionPromise.complete(conn1);
                  });
    }
    return sqlConnectionPromise.future();
  }
