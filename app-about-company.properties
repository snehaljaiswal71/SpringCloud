 public BankingModernizationHandler(
      JsonObject config,
      TransactionalReferenceDataService transactionalReferenceDataService,
      KafkaPublisherService publisherService,
      Vertx vertx) {
    super(vertx, transactionalReferenceDataService, config, EventBusConstants.CDC_MER_BANK_ACCT_EB);
    // TODO: Add address as parameter in place of empty String and enable in DBimplNew
    Objects.requireNonNull(config, "config is required and missing.");
    Objects.requireNonNull(
        transactionalReferenceDataService, "dataStoreService is required and missing.");
    Objects.requireNonNull(publisherService, "publisherService is required and missing.");

    this.config = config;
    this.publisherService = publisherService;
    this.localization = config.getString(LOCALIZATION);
    validatorService = new ValidatorServiceImpl(DataProcessorMainVerticle.validatorComponent);
    bankIndMapper = new BankIndMapper();
    if (localization != null && localization.contains(INDIA)) {
      config.put("data_type", DATA);
    } else {
      config.put("data_type", VALIDATED_DATA);
    }
  }



private Future<JsonArray> sendEventToValidator(
      JsonObject content,
      String batchCorrelationId,
      String address,
      String timeZone,
      JsonObject dataStoreConfig,
      String tableName) {

    LOGGER.debug(
        "BatchCorrelationId: {}, Address: {}, Sending data to validator Jar, Size: {}",
        batchCorrelationId,
        address,
        content.getJsonArray("rows") != null ? content.getJsonArray("rows").size() : null);

    Promise<JsonArray> promise = Promise.promise();
    validatorService
        .callToValidatorJar(content, batchCorrelationId, address)
        .onSuccess(
            response -> {
              LOGGER.debug(
                  "BatchCorrelationId: {}, Address: {}, {} Response from validator Jar, Size:{}",
                  batchCorrelationId,
                  address,
                  response.getString(STATUS),
                  response.getJsonArray(ROWS) != null ? response.getJsonArray(ROWS).size() : null);

              // call create 3 different methods for 3 cases.
              String status = response.getString(STATUS);

              response.getJsonArray(ROWS).stream()
                  .forEach(
                      row -> {
                        JsonObject rowJson = ((JsonArray) row).getJsonObject(0);
                        if (rowJson.getBoolean(STATUS)) {
                          LOGGER.info(
                              "BatchCorrelationId: {}, RowCorrelationId: {}, Address: {}, CHKPT_COMPLETE :: Data validation / transformation complete: Batch Status: {}, Row Status: {}",
                              batchCorrelationId,
                              rowJson.getMap().get("row_corr_id"),
                              address,
                              status,
                              rowJson.getString(STATUS).toUpperCase());
                        } else {
                          LOGGER.error(
                              "BatchCorrelationId: {}, RowCorrelationId: {}, Address: {}, CHKPT_FAILED :: Data validation / transformation failed: Batch Status: {}, Row Status: {}, Error: {}",
                              batchCorrelationId,
                              rowJson.getMap().get("row_corr_id"),
                              address,
                              status,
                              rowJson.getString(STATUS).toUpperCase(),
                              rowJson.getJsonArray("errors"));
                        }
                      });

              if (status != null) {
                switch (status) {
                  case "SUCCESS":
                    successResponseFromValidator(
                            response,
                            batchCorrelationId,
                            timeZone,
                            address,
                            dataStoreConfig,
                            tableName)
                        .onSuccess(
                            dbRes -> {
                              LOGGER.debug(
                                  "BatchCorrelationId: {}, Address: {}, Response from DB jar Size: {}",
                                  batchCorrelationId,
                                  address,
                                  dbRes != null ? dbRes.size() : null);
                              promise.complete(dbRes);
                            })
                        .onFailure(
                            err -> {
                              promise.fail(
                                  "Error while DB processing Or Params creation "
                                      + err.getLocalizedMessage());
                            });
                    break;

                  case "PARTIAL":
                    partialResponseFromValidator(
                            response,
                            batchCorrelationId,
                            timeZone,
                            address,
                            dataStoreConfig,
                            tableName)
                        .onSuccess(
                            dbRes -> {
                              LOGGER.debug(
                                  "BatchCorrelationId: {}, Address: {}, Response from DB jar Size: {}",
                                  batchCorrelationId,
                                  address,
                                  dbRes != null ? dbRes.size() : null);
                              promise.complete(dbRes);
                            })
                        .onFailure(
                            err -> {
                              promise.fail(
                                  "Error while DB processing Or Params creation "
                                      + err.getLocalizedMessage());
                            });
                    break;

                  case "FAILED":
                    failedResponseFromValidator(response, batchCorrelationId, timeZone, address)
                        .onSuccess(
                            dbRes -> {
                              LOGGER.debug(
                                  "BatchCorrelationId: {}, Address: {}, Response from DB jar Size: {}",
                                  batchCorrelationId,
                                  address,
                                  dbRes != null ? dbRes.size() : null);
                              promise.complete(dbRes);
                            })
                        .onFailure(
                            err -> {
                              promise.fail(
                                  "Error while DB processing Or Params creation "
                                      + err.getLocalizedMessage());
                            });
                    break;

                  default:
                    promise.fail("Unrecognised Status from Validator Jar");
                    throw new IllegalStateException("Unrecognised Status from Validator Jar");
                }
              } else {
                LOGGER.error(
                    "BatchCorrelationId: {}, Address: {}, Validation Jar issue : status null",
                    batchCorrelationId,
                    address);
                promise.fail("Validation Jar issue : status null");
              }
            })
        .onFailure(
            err -> {
              LOGGER.error(
                  "BatchCorrelationId: {}, Address: {}, Eventbus Failure, Something went wrong in Validator Jar. Reason: {}, Trace: {}",
                  batchCorrelationId,
                  address,
                  err.getLocalizedMessage(),
                  err);
              promise.fail(err);
            });

    return promise.future();
  }

public interface ValidatorService {

  AtomicReference<ValidatorDirectInstance> validatorDirectInstance = new AtomicReference<>();

  public Future<JsonObject> callToValidatorJar(
      JsonObject input, String batchCorrelationId, String address);
}


package com.aexp.gmdl.data.processor.service.impl;



public class ValidatorServiceImpl implements ValidatorService {

  private static final Logger LOGGER = LoggerFactory.getLogger(ValidatorServiceImpl.class);

  public static ValidatorDirectInstance validatorDirectInstance = null;

  public ValidatorServiceImpl() {}

  public ValidatorServiceImpl(ValidatorDirectInstance validatorDirectInstance) {
    ValidatorServiceImpl.validatorDirectInstance = validatorDirectInstance;
  }

  @Override
  public Future<JsonObject> callToValidatorJar(
      JsonObject input, String batchCorrelationId, String address) {

    Promise<JsonObject> mainPromise = Promise.promise();

    try {
      if (validatorDirectInstance != null) {
        validatorDirectInstance
            .processData(input, null)
            .onComplete(
                reply -> {
                  if (reply.succeeded()) {
                    mainPromise.complete(reply.result());
                  } else {
                    mainPromise.fail(reply.cause());
                  }
                });
      } else {
        LOGGER.error(
            "BatchCorrelationId: {}, validatorDirectInstance in ValidatorServiceImpl is null address: {}",
            batchCorrelationId,
            address);
        mainPromise.fail("validatorDirectInstance in ValidatorServiceImpl is null");
      }

    } catch (Exception e) {
      LOGGER.error(
          "BatchCorrelationId: {}, Exception in ValidatorServiceImpl while called validator JAR."
              + " address: {}, Error: {}, Trace: {}",
          batchCorrelationId,
          address,
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
      mainPromise.fail(e.getLocalizedMessage());
    }
    return mainPromise.future();
  }
}
