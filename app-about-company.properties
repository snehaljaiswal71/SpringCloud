package com.aexp.gmdl.db.component.util;

import static com.aexp.gmdl.db.component.constants.AppConstants.*;
import static com.aexp.gmdl.db.component.constants.AppConstants.DBErrorCategory.FATAL;
import static com.aexp.gmdl.db.component.constants.AppConstants.DBErrorCategory.INTERRUPTEDEXCEPTION;
import static java.util.Objects.requireNonNull;

import com.aexp.gmdl.db.component.config.DBConfiguration;
import io.vertx.core.*;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import java.sql.SQLException;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;

public class DBUtil {

  private static final Logger LOGGER = LoggerFactory.getLogger(DBUtil.class);
  public static final String INSTANCE = "instance";

  Vertx vertx;
  public JsonObject config;

  Map<String, Map<String, Object>> dbMap = new HashMap();

  public DBUtil(Vertx vertx, JsonObject config, Marker classMarker) {
    requireNonNull(config, "config is required and missing.");
    this.vertx = vertx;
    this.config = config;
    dbMap.forEach(
        (key, obj) -> {
          obj = null;
        });

    dbMap = new HashMap<>();
  }

  private DBConfiguration getDBConfigObject(
      JsonObject configJson, Boolean type, String correlationId, Marker marker) {
    DBConfiguration dbConfig = new DBConfiguration();
    try {
      String isPrimaryOrSecondary = type ? "primary" : "secondary";
      JsonObject dbConf = configJson.getJsonObject(isPrimaryOrSecondary);
      LOGGER.info(
          marker,
          "{} : CorrelationId: {}, db-url: {}",
          DB_JAR,
          correlationId,
          dbConf.getString("url"));

      dbConfig.setUrl(dbConf.getString("url"));
      dbConfig.setJdbcDriverClass(dbConf.getString("driver_class"));
      dbConfig.setMaxPoolSize(dbConf.getInteger("max_pool_size"));
      dbConfig.setMinPoolSize(dbConf.getInteger("min_pool_size"));
      dbConfig.setDataSourceName(dbConf.getString("datasourceName"));
      dbConfig.setUserId(dbConf.getString("user"));
      dbConfig.setPassword(dbConf.getString("password"));
      dbConfig.setInitialPoolSize(dbConf.getInteger("initial_pool_size"));
      dbConfig.setMaxIdleTime(dbConf.getInteger("max_idle_time"));
      dbConfig.setBreakAfterAcquireFailure(dbConf.getBoolean("breakAfterAcquisitionFailure", true));
      dbConfig.setAcquireRetryAttempts(dbConf.getInteger("acquire_retry_attempts"));

    } catch (Exception e) {
      LOGGER.error(
          marker,
          "{} : CorrelationId: {}, Exception while getDBConfigObject, Reason: {}, Trace: {}",
          DB_JAR_ERROR,
          correlationId,
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
    }

    return dbConfig;
  }

  public void getConnection(
      String dbName,
      String correlationId,
      Marker marker,
      Handler<AsyncResult<SQLConnection>> handler) {
    Promise<SQLConnection> sqlConnectionPromise = Promise.promise();
    try {
      LOGGER.debug(
          marker,
          "{} : CorrelationId: {}, getConnection, CurrentPool: {}, dbName: {}",
          DB_JAR,
          correlationId,
          dbMap.get(dbName) == null
              ? "primary"
              : Boolean.TRUE.equals(dbMap.get(dbName).get("primary")) ? "primary" : "secondary",
          dbName);

      getConnectionFromDB(
          dbName,
          correlationId,
          marker,
          true,
          conn -> {
            if (conn.succeeded()) {
              LOGGER.debug(
                  marker,
                  "{} : CorrelationId: {}, connection successful from existing {} pool, dbName: {}",
                  DB_JAR,
                  correlationId,
                  Boolean.TRUE.equals(dbMap.get(dbName).get("primary")) ? "primary" : "secondary",
                  dbName);

              sqlConnectionPromise.complete(conn.result());
            } else {
              LOGGER.error(
                  marker,
                  "{} : CorrelationId: {}, {} connection failed from existing {} pool, going for reAttemptConnection",
                  DB_JAR_ERROR,
                  correlationId,
                  dbName,
                  Boolean.TRUE.equals(dbMap.get(dbName).get("primary")) ? "primary" : "secondary");
              reAttemptConnection(
                  sqlConnectionPromise, dbName, correlationId, conn.cause(), marker);
            }
          });

    } catch (Exception e) {
      LOGGER.error(
          marker,
          "{} : CorrelationId: {}, Exception: connection failed from existing pool for: {}. dbMap size: {}, Reason: {}, Trace: {}",
          DB_JAR_ERROR,
          correlationId,
          dbName,
          dbMap.size(),
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
      sqlConnectionPromise.fail(e.getLocalizedMessage());
    }
    sqlConnectionPromise
        .future()
        .onComplete(
            done -> {
              handler.handle(sqlConnectionPromise.future());
            });
  }

  public Future<SQLConnection> getConnection(
      String dbName, boolean secondaryDBAttemptRequired, String correlationId, Marker marker) {
    Promise<SQLConnection> sqlConnectionPromise = Promise.promise();
    try {
      LOGGER.debug(
          marker,
          "{} : CorrelationId: {}, going to get connection, CurrentPool: {}, dbName: {}",
          DB_JAR,
          correlationId,
          "primary",
          dbName);

      if (!secondaryDBAttemptRequired) {
        getConnectionFromDB(
            dbName,
            correlationId,
            marker,
            true,
            conn -> {
              if (conn.succeeded()) {
                LOGGER.debug(
                    marker,
                    "{} : CorrelationId: {}, connection successful from existing {} pool, dbName: {}",
                    DB_JAR,
                    correlationId,
                    Boolean.TRUE.equals(dbMap.get(dbName).get("primary")) ? "primary" : "secondary",
                    dbName);
                sqlConnectionPromise.complete(conn.result());
              } else {
                LOGGER.error(
                    marker,
                    "{} : CorrelationId: {}, {} connection failed from existing {} pool, going for "
                        + "reAttemptConnection",
                    DB_JAR_ERROR,
                    correlationId,
                    dbName,
                    Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                        ? "primary"
                        : "secondary");
                reAttemptConnection(
                    sqlConnectionPromise, dbName, correlationId, conn.cause(), marker);
              }
            });

      } else {
        reAttemptConnection(
            sqlConnectionPromise, dbName, correlationId, new Throwable("FATAL"), marker);
      }
    } catch (Exception e) {
      LOGGER.error(
          marker,
          "{} : CorrelationId: {}, Exception connection failed from existing pool for: {}.dbMap size: {}, Reason: {}, Trace: {}",
          DB_JAR_ERROR,
          correlationId,
          dbName,
          dbMap.size(),
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
      sqlConnectionPromise.fail(e.getLocalizedMessage());
    }
    return sqlConnectionPromise.future();
  }

  public void getConnectionFromDB(
      String dbName,
      String correlationId,
      Marker marker,
      boolean isPrimary,
      Handler<AsyncResult<SQLConnection>> handler) {

    Instant start = Instant.now();
    if (dbMap.get(dbName) == null || dbMap.get(dbName).get(INSTANCE) == null) {
      synchronized (this) {
        if (dbMap.get(dbName) == null || dbMap.get(dbName).get(INSTANCE) == null) {
          // Only 1 instance will be stored in this hashmap , either primary or secondary
          Map<String, Object> dbInstance = new HashMap();
          dbInstance.put(INSTANCE, getJDBCInstance(dbName, correlationId, isPrimary, marker));
          dbInstance.put("primary", true);
          dbMap.put(dbName, dbInstance);
        }
      }
    }
    try {
      Promise<SQLConnection> connPromise = Promise.promise();
      ((JDBCClient) dbMap.get(dbName).get(INSTANCE))
          .getConnection(
              connection -> {
                if (connection.succeeded()) {
                  LOGGER.debug(
                      marker,
                      "{} : CorrelationId: {}, connection successfully established for {} with {}, duration: {}",
                      DB_JAR,
                      correlationId,
                      dbName,
                      Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                          ? "primary"
                          : "secondary",
                      Duration.between(start, Instant.now()).getSeconds());

                  connPromise.complete(connection.result());
                  handler.handle(connPromise.future());
                } else {
                  LOGGER.error(
                      marker,
                      "{} : CorrelationId: {}, Connection to {} failed with {}, Reason: {}, Trace: {}",
                      DB_JAR_ERROR,
                      correlationId,
                      dbName,
                      Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                          ? "primary"
                          : "secondary",
                      connection.cause() != null
                          ? connection.cause().getLocalizedMessage()
                          : "Cause is null",
                      connection.cause());
                  connPromise.fail(connection.cause());
                  handler.handle(connPromise.future());
                }
              });
    } catch (Exception e) {
      LOGGER.error("Unknown Some issue with JDBC connection , {}", ExceptionUtils.getStackTrace(e));
      Promise<SQLConnection> connPromise = Promise.promise();
      connPromise.fail("Unknown issue with db, stacktrace : " + ExceptionUtils.getStackTrace(e));
      handler.handle(connPromise.future());
    }
  }

  private void reAttemptConnection(
      Promise<SQLConnection> sqlConnectionPromise,
      String dbName,
      String correlationId,
      Throwable err,
      Marker marker) {
    LOGGER.debug(
        marker,
        "{} : CorrelationId: {}, Reattempt connection as previous connection failed pool.",
        DB_JAR_ERROR,
        correlationId);

    Long connectionReAttemptDelay =
        this.config
            .getJsonObject("db-config")
            .getJsonObject(dbName)
            .getLong("connection_reattempt_delay", 500L);

    DBErrorCategory dbErrorCategory = getDBConnErrorCategory(err, correlationId, marker);
    switch (dbErrorCategory) {
      case USER_ACCOUNT_ISSUE:
      case INTERRUPTEDEXCEPTION:
      case FATAL:
        {
          switchUserAndGetConnection(dbName, correlationId, marker, false)
              .onSuccess(
                  conn -> {
                    LOGGER.debug(
                        marker,
                        "{} : CorrelationId: {}, connection successful after switch from {} pool",
                        DB_JAR,
                        correlationId,
                        Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                            ? "primary"
                            : "secondary");
                    sqlConnectionPromise.complete(conn);
                  })
              .onFailure(
                  err1 -> {
                    LOGGER.error(
                        marker,
                        "{} : CorrelationId: {}, connection failed from {} pool even after switch Unable to get conn "
                            + "from primary and secondary, Reason: {} , Trace: {}",
                        DB_JAR_ERROR,
                        correlationId,
                        Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                            ? "primary"
                            : "secondary",
                        err1.getLocalizedMessage(),
                        err1);
                    sqlConnectionPromise.fail(err1);
                  });
        }
        break;
      case DNS_RESOLUTION_ERROR:
        {
          LOGGER.info(
              marker,
              "{} : CorrelationId: {}, Attempt to recover from DNS error for {} DB. Triggering timer",
              DB_JAR,
              correlationId,
              dbName);
          if (Boolean.FALSE.equals(dbMap.get(dbName).get("primary"))) {
            dbMap.get(dbName).put(INSTANCE, null);
            dbMap.get(dbName).put("primary", true);
          }
          vertx.setTimer(
              connectionReAttemptDelay,
              handler -> {
                getConnectionFromDB(
                    dbName,
                    correlationId,
                    marker,
                    true,
                    conn -> {
                      if (conn.succeeded()) {
                        LOGGER.debug(
                            marker,
                            "{} : CorrelationId: {}, connection successful from existing {} pool for {} DB.",
                            DB_JAR,
                            correlationId,
                            Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                                ? "primary"
                                : "secondary",
                            dbName);
                        vertx.cancelTimer(handler);
                        sqlConnectionPromise.complete(conn.result());
                      } else {
                        LOGGER.error(
                            marker,
                            "{} : CorrelationId: {}, Unable to recover from DNS resolution for {} DB, error "
                                + "after {} ms, Reason: {} , Trace: {}",
                            DB_JAR_ERROR,
                            correlationId,
                            dbName,
                            connectionReAttemptDelay,
                            conn.cause().getLocalizedMessage(),
                            conn.cause());
                        sqlConnectionPromise.fail(conn.cause());
                      }
                    });
              });
        }
        break;
      case POOL_BROKEN:
      case CLIENT_IS_CLOSED:
        {
          LOGGER.info(
              marker,
              "{} : CorrelationId: {}, connection failed with {} DB with Pool broken OR Client is closed error. Try one more time",
              DB_JAR,
              correlationId,
              dbName);

          dbMap.get(dbName).put(INSTANCE, null);
          if (Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))) {
            dbMap.get(dbName).put("primary", true);
          } else {
            dbMap.get(dbName).put("primary", false);
          }
          getConnectionFromDB(
              dbName,
              correlationId,
              marker,
              (Boolean) dbMap.get(dbName).get("primary"),
              conn -> {
                if (conn.succeeded()) {
                  LOGGER.debug(
                      marker,
                      "{} : CorrelationId: {}, connection successful from existing {} pool for {} DB.",
                      DB_JAR,
                      correlationId,
                      Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                          ? "primary"
                          : "secondary",
                      dbName);
                  sqlConnectionPromise.complete(conn.result());
                } else {
                  LOGGER.error(
                      marker,
                      "{} : CorrelationId: {}, Unable to recover from connection failure for {} DB, Reason: {}, "
                          + "Trace: {}",
                      DB_JAR_ERROR,
                      correlationId,
                      dbName,
                      conn.cause().getLocalizedMessage(),
                      conn);
                  sqlConnectionPromise.fail(conn.cause());
                }
              });
        }
        break;

      default:
        {
          LOGGER.info(
              marker,
              "{} : CorrelationId: {}, connection failed with DB with Default error. Try one more time",
              DB_JAR,
              correlationId);

          getConnectionFromDB(
              dbName,
              correlationId,
              marker,
              false,
              conn -> {
                if (conn.succeeded()) {
                  LOGGER.debug(
                      marker,
                      "{} : CorrelationId: {}, connection successful from existing {} pool for {} DB",
                      DB_JAR,
                      correlationId,
                      Boolean.TRUE.equals(dbMap.get(dbName).get("primary"))
                          ? "primary"
                          : "secondary",
                      dbName);
                  sqlConnectionPromise.complete(conn.result());
                } else {
                  LOGGER.error(
                      marker,
                      "{} : CorrelationId: {}, Unable to recover from connection failure for {} DB, Reason: {}, "
                          + "Trace: {}",
                      DB_JAR_ERROR,
                      correlationId,
                      dbName,
                      conn.cause().getLocalizedMessage(),
                      conn);
                  sqlConnectionPromise.fail(conn.cause());
                }
              });
        }
        break;
    }
  }

  private Future<SQLConnection> switchUserAndGetConnection(
      String dbName, String correlationId, Marker marker, boolean isPrimary) {
    Promise<SQLConnection> sqlConnectionPromise = Promise.promise();

    LOGGER.info(
        marker, "{} : CorrelationId: {}, {} DB Switchover started.", DB_JAR, correlationId, dbName);

    long primarySwitchInterval =
        this.config
            .getJsonObject("db-config")
            .getJsonObject(dbName)
            .getLong("primary_switch_interval", 1800000L);
    getConnectionFromDB(
        dbName,
        correlationId,
        marker,
        isPrimary,
        conn -> {
          if (conn.succeeded()) {
            LOGGER.debug(
                marker,
                "{} : CorrelationId: {}, connection successful from existing {} pool, dbName: {}",
                DB_JAR,
                correlationId,
                Boolean.TRUE.equals(dbMap.get(dbName).get("primary")) ? "primary" : "secondary",
                dbName);

            sqlConnectionPromise.complete(conn.result());
            vertx.setPeriodic(
                primarySwitchInterval,
                timerId -> {
                  schedulePrimaryConnCheck(dbName, timerId, correlationId, marker);
                });
          } else {
            LOGGER.error(
                marker,
                "{} : CorrelationId: {}, {} connection failed from existing {} pool, going for "
                    + "reAttemptConnection",
                DB_JAR_ERROR,
                correlationId,
                dbName,
                Boolean.TRUE.equals(dbMap.get(dbName).get("primary")) ? "primary" : "secondary");
            reAttemptConnection(sqlConnectionPromise, dbName, correlationId, conn.cause(), marker);
          }
        });

    return sqlConnectionPromise.future();
  }

  private void schedulePrimaryConnCheck(
      String dbName, Long handler, String correlationId, Marker marker) {

    LOGGER.info(
        "{} : CorrelationId: {}, checking whether the primary user is up or not for DB!",
        DB_JAR,
        correlationId);

    try {

      JDBCClient tempJdbcClient = getJDBCInstance(dbName, correlationId, true, marker);
      tempJdbcClient.getConnection(
          connectionHandler2 -> {
            if (connectionHandler2.succeeded()) {
              dbMap.get(dbName).put(INSTANCE, tempJdbcClient);
              dbMap.get(dbName).put("type", "primary");
              vertx.cancelTimer(handler);
            } else {
              LOGGER.error(
                  marker,
                  "{} : CorrelationId: {}, Scheduler: Primary user for {} DB is still down. cause: {}, trace:"
                      + " {}",
                  DB_JAR_ERROR,
                  correlationId,
                  dbName,
                  connectionHandler2.cause().getLocalizedMessage(),
                  connectionHandler2.cause());
            }
          });

    } catch (Exception e) {
      LOGGER.error(
          marker,
          "{} : CorrelationId: {}, Error while Scheduler: Primary user for {} DB",
          DB_JAR_ERROR,
          correlationId,
          dbName);
    }
  }

  private JDBCClient getJDBCInstance(
      String dbName, String correlationId, boolean isPrimary, Marker marker) {

    LOGGER.info(
        "{} : CorrelationId: {}, creating the new {} pool with {} config, DB-config: {}",
        DB_JAR,
        correlationId,
        dbName,
        isPrimary ? "Primary" : "Secondary",
        removePassword(
            this.config.getJsonObject("db-config").getJsonObject(dbName), correlationId, marker));
    return JDBCClient.create(
        vertx,
        JsonObject.mapFrom(
                getDBConfigObject(
                    this.config.getJsonObject("db-config").getJsonObject(dbName),
                    isPrimary,
                    correlationId,
                    marker))
            .put("provider_class", "io.vertx.ext.jdbc.spi.impl.C3P0DataSourceProvider")
            .put("decoderCls", CustomJDBCDecoderImpl.class.getName()));
  }

  private DBErrorCategory getDBConnErrorCategory(
      Throwable throwable, String correlationId, Marker marker) {
    if (throwable == null) return DBErrorCategory.UNCATEGORIZED;

    String errMessage = throwable.getLocalizedMessage();
    if (errMessage != null) {
      if (throwable instanceof InterruptedException
          || errMessage.contains("InterruptedException")) {
        LOGGER.error(
            marker,
            "{} : CorrelationId: {}, InterruptedException in DB JAR for DB. Error: {}",
            DB_JAR,
            correlationId,
            errMessage);
        return INTERRUPTEDEXCEPTION;
      } else if (errMessage.contains("FATAL")
          || errMessage.contains("Fatal")
          || errMessage.contains("fatal")) {
        LOGGER.info(
            marker,
            "{} : CorrelationId: {}, Fatal in DB JAR for DB. Error: {}",
            DB_JAR,
            correlationId,
            errMessage);
        return FATAL;
      } else {
        if (errMessage.contains(FAILED_TO_RESOLVE)) return DBErrorCategory.DNS_RESOLUTION_ERROR;
        else if (errMessage.contains("Attempted to use a closed or broken resource pool"))
          return DBErrorCategory.POOL_BROKEN;
        else if (errMessage.contains("Client is closed")) return DBErrorCategory.CLIENT_IS_CLOSED;
        else {
          if (throwable instanceof SQLException) {
            SQLException sqlException = (SQLException) throwable;
            // Class 28 — Invalid Authorization Specification
            if (sqlException.getSQLState() == null
                || (sqlException.getSQLState() != null
                    && sqlException.getSQLState().startsWith("28"))) {
              LOGGER.info(
                  marker,
                  "{} : CorrelationId: {}, Invalid Authorization Specification in DB JAR for DB. Error: {}",
                  DB_JAR,
                  correlationId,
                  errMessage);
              return DBErrorCategory.USER_ACCOUNT_ISSUE;
            } else return DBErrorCategory.UNCATEGORIZED;
          } else return DBErrorCategory.UNCATEGORIZED;
        }
      }
    } else {
      LOGGER.error(
          marker,
          "{} : CorrelationId: {}, Throwable for errMessage is null, errMessage: {}, Throwable: {}",
          DB_JAR_ERROR,
          correlationId,
          errMessage,
          throwable);
      return DBErrorCategory.UNCATEGORIZED;
    }
  }

  private JsonObject removePassword(JsonObject dbConfig, String correlationId, Marker marker) {
    JsonObject jsonObject;
    try {
      String rx = "\"password\":\"(.*?)\",";
      String input = dbConfig.toString();
      String output = dbConfig.toString();
      Pattern p = Pattern.compile(rx);
      Matcher m = p.matcher(input);
      while (m.find()) {
        String repString1 = m.group(1);
        if (repString1 != null) output = output.replaceFirst(repString1, "********");
      }
      jsonObject = new JsonObject(output);
    } catch (Exception e) {
      jsonObject = new JsonObject();
      LOGGER.error(
          marker,
          "{} : CorrelationId: {}, Exception while removing password, Error: {}, Cause: {}",
          DB_JAR_ERROR,
          correlationId,
          e.getLocalizedMessage(),
          e.getCause());
    }
    return jsonObject;
  }
}
