private Future<JsonArray> fieldEncryptionDecryption(
      JsonArray content, String batchCorrelationId, String address, String rule_nm) {

    Promise<JsonArray> promise = Promise.promise();
    try {
      JsonArray rows = new JsonArray();
      content.forEach(
          obj -> {
            JsonObject data = ((JsonObject) obj);
            JsonObject entries = new JsonObject();

            entries.put("row_corr_id", data.getString("row_corr_id"));
            entries.put("event_type", data.getString("event_type"));
            entries.put(
                "data",
                new JsonArray()
                    .add(
                        data.containsKey("validated_data")
                            ? data.getJsonObject("validated_data")
                            : data.getJsonArray("data").getJsonObject(0)));
            rows.add(entries);
          });

      JsonObject request = new JsonObject();
      request.put("isIgnoreCommonConfig", true);
      request.put(CORRELATION_UNDERSCORE_ID, batchCorrelationId);
      request.put("table_nm", rule_nm);
      request.put("channel_id", "processor");
      request.put("query_timeout", 3000);
      request.put("rows", rows);

      validatorService
          .callToValidatorJar(request, batchCorrelationId, address)
          .onSuccess(
              response -> {
                LOGGER.info(
                    "BatchCorrelationId: {}, Address: {}, {} Response from validator Jar after {}, Size:{}",
                    batchCorrelationId,
                    address,
                    response.getString("status"),
                    rule_nm,
                    response.getJsonArray("rows") != null
                        ? response.getJsonArray("rows").size()
                        : null);

                // call create 3 different methods for 3 cases.
                String status = response.getString("status");
                if (status != null) {
                  switch (status) {
                    case "SUCCESS":
                      promise.complete(response.getJsonArray(ROWS));
                      break;

                    case "PARTIAL":
                      {
                        LOGGER.error(
                            "BatchCorrelationId: {}, Address: {}, High Alert: PARTIAL Response from VD JAR while calling for Encryption-Decryption.",
                            batchCorrelationId,
                            address);
                        promise.complete(response.getJsonArray(ROWS));
                        break;
                      }

                    case "FAILED":
                      {
                        LOGGER.error(
                            "BatchCorrelationId: {}, Address: {}, High Alert: FAILED Response from VD JAR while calling for Encryption-Decryption.",
                            batchCorrelationId,
                            address);
                        //                        FIXME: SHOULD NOT GO TO DB IF ENCRYPTION FAILS
                        promise.fail("");
                        break;
                      }
                  }
                } else {
                  LOGGER.error(
                      "BatchCorrelationId: {}, Address: {}, High Alert: Validation Jar issue while calling decryption for publish: status null",
                      batchCorrelationId,
                      address);
                  promise.fail("Validation Jar issue : status null");
                }
              })
          .onFailure(
              err -> {
                LOGGER.error(
                    "BatchCorrelationId: {}, Address: {}, High Alert: Eventbus Failure, Something went wrong in Validator Jar. Reason: {}, Trace: {}",
                    batchCorrelationId,
                    address,
                    err.getLocalizedMessage(),
                    err);
                promise.fail(err);
              });
    } catch (Exception e) {
      LOGGER.error(
          "BatchCorrelationId: {}, Address: {}, Exception occurred in fieldEncryptionDecryption. Reason: {}, Trace: {}",
          batchCorrelationId,
          address,
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
      promise.fail(e);
    }
    return promise.future();
  }

 public BankingModernizationHandler(
      JsonObject config,
      TransactionalReferenceDataService transactionalReferenceDataService,
      KafkaPublisherService publisherService,
      Vertx vertx) {
    super(vertx, transactionalReferenceDataService, config, EventBusConstants.CDC_MER_BANK_ACCT_EB);
    // TODO: Add address as parameter in place of empty String and enable in DBimplNew
    Objects.requireNonNull(config, "config is required and missing.");
    Objects.requireNonNull(
        transactionalReferenceDataService, "dataStoreService is required and missing.");
    Objects.requireNonNull(publisherService, "publisherService is required and missing.");

    this.config = config;
    this.publisherService = publisherService;
    this.localization = config.getString(LOCALIZATION);
    validatorService = new ValidatorServiceImpl(DataProcessorMainVerticle.validatorComponent);
    bankIndMapper = new BankIndMapper();
    if (localization != null && localization.contains(INDIA)) {
      config.put("data_type", DATA);
    } else {
      config.put("data_type", VALIDATED_DATA);
    }
  }
