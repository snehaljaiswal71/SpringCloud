import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.util.HashMap;
import java.util.Properties;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class RTFPublisherServiceTest {

    private RTFPublisherService rtfPublisherService;

    @BeforeEach
    void setUp() {
        rtfPublisherService = new RTFPublisherService();
    }

    @Test
    void testPublishToRTFSuccess() throws Exception {
        // Mock inputs
        JsonObject requestBody = new JsonObject().put("key", "value");
        JsonObject header = new JsonObject().put("headerKey", "headerValue");
        JsonObject config = new JsonObject()
                .put("RTF_CONFIG", new JsonObject()
                        .put("ENV", "test_env")
                        .put("PROVIDER_CLASS", "com.example.Provider")
                        .put("EVENT_NAME", "test_event"));
        Vertx vertx = mock(Vertx.class);

        // Mock RtfClient and its response
        RtfClient mockClient = mock(RtfClient.class);
        RtfResponse mockResponse = mock(RtfResponse.class);

        when(mockResponse.getHttpStatusCode()).thenReturn(200);
        when(mockResponse.getResponseSource()).thenReturn("source");
        when(mockResponse.getDataCenter()).thenReturn("dataCenter");
        when(mockClient.execute(any(RtfRequest.class), eq(1))).thenReturn(mockResponse);

        // Mock factory
        mockStatic(RTFClientFactory.class);
        when(RTFClientFactory.getRtfClient(any(Properties.class))).thenReturn(mockClient);

        // Invoke the method
        Future<JsonObject> result = rtfPublisherService.publishToRTF(requestBody, header, config, vertx);

        // Verify and assert
        assertTrue(result.succeeded());
        JsonObject expectedResponse = new JsonObject()
                .put("httpStatusCode", 200)
                .put("responseSource", "source")
                .put("dataCennter", "dataCenter");
        assertEquals(expectedResponse, result.result());
    }

    @Test
    void testPublishToRTFFailureWithException() throws Exception {
        // Mock inputs
        JsonObject requestBody = new JsonObject().put("key", "value");
        JsonObject header = new JsonObject().put("headerKey", "headerValue");
        JsonObject config = new JsonObject()
                .put("RTF_CONFIG", new JsonObject()
                        .put("ENV", "test_env")
                        .put("PROVIDER_CLASS", "com.example.Provider")
                        .put("EVENT_NAME", "test_event"));
        Vertx vertx = mock(Vertx.class);

        // Mock RtfClientFactory to throw exception
        mockStatic(RTFClientFactory.class);
        when(RTFClientFactory.getRtfClient(any(Properties.class))).thenThrow(new RuntimeException("RTF Client creation error"));

        // Invoke the method
        Future<JsonObject> result = rtfPublisherService.publishToRTF(requestBody, header, config, vertx);

        // Verify and assert
        assertTrue(result.failed());
        assertEquals("RTF Client creation error", result.cause().getMessage());
    }

    @Test
    void testPublishToRTFErrorResponse() throws Exception {
        // Mock inputs
        JsonObject requestBody = new JsonObject().put("key", "value");
        JsonObject header = new JsonObject().put("headerKey", "headerValue");
        JsonObject config = new JsonObject()
                .put("RTF_CONFIG", new JsonObject()
                        .put("ENV", "test_env")
                        .put("PROVIDER_CLASS", "com.example.Provider")
                        .put("EVENT_NAME", "test_event"));
        Vertx vertx = mock(Vertx.class);

        // Mock RtfClient and its response
        RtfClient mockClient = mock(RtfClient.class);
        RtfResponse mockResponse = mock(RtfResponse.class);

        when(mockResponse.getHttpStatusCode()).thenReturn(500);
        when(mockResponse.getThrowable()).thenReturn(new Throwable("Internal Server Error"));
        when(mockClient.execute(any(RtfRequest.class), eq(1))).thenReturn(mockResponse);

        // Mock factory
        mockStatic(RTFClientFactory.class);
        when(RTFClientFactory.getRtfClient(any(Properties.class))).thenReturn(mockClient);

        // Invoke the method
        Future<JsonObject> result = rtfPublisherService.publishToRTF(requestBody, header, config, vertx);

        // Verify and assert
        assertTrue(result.failed());
        assertEquals("Internal Server Error", result.cause().getMessage());
    }
}
