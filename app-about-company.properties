void handle(final Message<JsonObject> message) {

    msgMarker = getMessageMarker(message, application);
    final String correlationId = message.headers().get(MicrodoseConstants.ONE_DATA_CORRELATION_ID);
    final String channelId =
            Optional.ofNullable(message.headers().get(DemographicsConstants.CHANNEL))
                    .orElse(DemographicsConstants.DEFAULT_CHANNEL).toUpperCase();
    final JsonObject request = message.body();
    JsonArray finalResponse = new JsonArray();

    String userId = configResult.getJsonObject("postgres-config", new JsonObject())
            .getJsonObject("gcharcore", new JsonObject())
            .getJsonObject("primary", new JsonObject())
            .getString("user");
    log.info(msgMarker, "New Request with channel id = {} , SOR , {}, correlation id = {} , request = {}, userId = {}",
            channelId, FUNCTION_NAME, correlationId, request, userId);

    final boolean gms = GMS_CONSUMERS.contains(channelId);

    try {
      final Optional<ErrorResponse> errors = validateRequest(request);
      if (errors.isPresent()) {
        final ErrorResponse errorResponse = errors.get();
        log.error(msgMarker, "Validation failed = {}", errorResponse);
        finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
        sendReply(msgMarker, message, correlationId, channelId, finalResponse, FAILURE, HttpStatus.SC_BAD_REQUEST);
      } else {
        processRequest(msgMarker, request, correlationId, gms).onFailure(cause -> {
          final ErrorResponse response =
                  new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR), cause.getLocalizedMessage());
          sendReply(msgMarker, message, correlationId, channelId, response.toJson(), FAILURE,
                  HttpStatus.SC_INTERNAL_SERVER_ERROR);
        }).onSuccess(response -> {
          if (null == response || response.isEmpty()) {
            log.info(msgMarker, "Response is null or empty from database");
            final ErrorResponse errorResponse = new ErrorResponse(String.valueOf(HttpStatus.SC_NOT_FOUND),
                    "RECORD_NOT_FOUND");
            try {
              finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
            } catch (JsonProcessingException e) {
              throw new RuntimeException(e);
            }
            sendReply(msgMarker, message, correlationId, channelId, finalResponse, FAILURE, HttpStatus.SC_NOT_FOUND);
          } else {
            sendReply(msgMarker, message, correlationId, channelId, response, SUCCESS, HttpStatus.SC_OK);
          }
        });
      }
    } catch (Exception e) {
      log.info(msgMarker, "EXCEPTION OCCURRED WHILE PROCESSING REQUEST. DETAILS = {}", e.getLocalizedMessage());
      final ErrorResponse response =
              new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR), e.getLocalizedMessage());
      sendReply(msgMarker, message, correlationId, channelId, response.toJson(), FAILURE,
              HttpStatus.SC_INTERNAL_SERVER_ERROR);
    }
  }

public <T> Structured getMessageMarker(Message<T> message, Application application) {
    message.headers().add(MicrodoseConstants.FUNCTION_CENTRAL_ID,
      config().getString(MicrodoseConstants.CENTRAL_ID, "NA"));
    Structured messageMarker = (Structured) MicrodoseLogger.generateMarker(message);
    messageMarker.withApplication(application);
    exceptionHandler(messageMarker);
    return messageMarker;
  }
