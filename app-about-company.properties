package com.axp.microdose.unified.merchant.read.demographics.sor;

import com.aexp.gmdl.db.component.InitializeDBComponent;
import com.aexp.gmdl.db.component.service.TransactionalReferenceDataService;
import com.aexp.sec.ssaashiped.KeyHandleFPE;
import com.aexp.sec.ssaashiped.crypto.fpe.CryptoFPE;
import com.aexp.sec.ssaashiped.exception.HiPEDException;
import com.axp.logging.schema.v0_1.Application;
import com.axp.logging.schema.v0_1.Structured;
import com.axp.microdose.commons.MicrodoseConstants;
import com.axp.microdose.data.AbstractMicrodoseVerticle;
import com.axp.microdose.unified.merchant.read.demographics.data.DemographicsNewDetailDbAction;
import com.axp.microdose.unified.merchant.read.demographics.util.*;
import com.axp.microdose.vertx.logging.Logger;
import com.axp.microdose.vertx.logging.LoggerFactory;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.http.HttpStatus;

import java.util.*;
import java.util.stream.IntStream;

import static com.axp.microdose.commons.MicrodoseConstants.LAMBDA_CONFIG;
import static com.axp.microdose.unified.merchant.read.demographics.util.DemographicsNewConstants.*;
import static org.apache.http.protocol.HTTP.CONTENT_TYPE;

public class ReadUnifiedMerchantDemographicsNewVerticle extends AbstractMicrodoseVerticle {

  private static final Logger log = LoggerFactory.getLogger(ReadUnifiedMerchantDemographicsNewVerticle.class);
  private Application application;
  private Structured classMarker;
  private TransactionalReferenceDataService dataService;
  private JsonObject configResult;
  private ObjectMapper objectMapper;
  private static final String FUNCTION_NAME = "ReadUnifiedMerchantDemographics.sor.v2";
  private JsonObject decryptConfig;
  private Structured msgMarker;
  private JsonObject encrConfig;

  @Override
  public void start(final Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    objectMapper = new ObjectMapper();
    application = getApplication(ReadUnifiedMerchantDemographicsNewVerticle.class);
    classMarker = getClassMarker(application);
    log.info(classMarker, "Starting {}", getClass().getSimpleName());
    decryptConfig = config().getJsonObject(LAMBDA_CONFIG).getJsonObject(DECRYPTION);

    ConfigRetrieverHelper.CONFIGURATION_RETRIEVER
            .withJsonObject(config())
            .withPropertiesFileStore("DemographicQueryV3.properties")
            .withEnvVariablesStore()
            .getConfig(vertx)
            .onSuccess(configResult -> {
              log.info(classMarker, "{} has started", getClass().getSimpleName());
              this.configResult = configResult;
              try {
                log.info(classMarker, "Before db initialized");
                InitializeDBComponent.initializeDBComponent(vertx, this.configResult, classMarker)
                        .onSuccess(res -> {
                          this.dataService = TransactionalReferenceDataService.create(
                                  this.vertx,
                                  this.configResult.getJsonObject(LAMBDA_CONFIG, new JsonObject()),
                                  TransactionalReferenceDataService.DBType.PG_DB, classMarker);
                          vertx.eventBus().consumer(getFunctionAddress(), this::handle);
                          startPromise.complete();
                        })
                        .onFailure(err -> {
                          log.error(classMarker, "ERROR while starting verticle,cause: {}",
                                  err.getLocalizedMessage(), err);
                          startPromise.fail(err.toString());
                        });
              } catch (Exception e) {
                log.error(classMarker, "Something went wrong", e);
                throw new RuntimeException(e);
              }
            });
  }

  @Override
  public void stop(Promise<Void> stopPromise) {
    try {
      super.stop(stopPromise);
      log.info(classMarker, "Stopped the " + FUNCTION_NAME + " verticle");
    } catch (Exception e) {
      log.error(classMarker, "ERROR : {} :  Failed to stop verticle, Error: {}, Trace: {}",
              FUNCTION_NAME, e.getLocalizedMessage(),
              ExceptionUtils.getStackFrames(e));
      stopPromise.fail(e.getLocalizedMessage());
    }
  }

  void handle(final Message<JsonObject> message) {

    msgMarker = getMessageMarker(message, application);
    final String correlationId = message.headers().get(MicrodoseConstants.ONE_DATA_CORRELATION_ID);
    final String channelId =
            Optional.ofNullable(message.headers().get(DemographicsConstants.CHANNEL))
                    .orElse(DemographicsConstants.DEFAULT_CHANNEL).toUpperCase();
    final JsonObject request = message.body();
    JsonArray finalResponse = new JsonArray();

    String userId = configResult.getJsonObject("postgres-config", new JsonObject())
            .getJsonObject("gcharcore", new JsonObject())
            .getJsonObject("primary", new JsonObject())
            .getString("user");
    log.info(msgMarker, "New Request with channel id = {} , SOR , {}, correlation id = {} , request = {}, userId = {}",
            channelId, FUNCTION_NAME, correlationId, request, userId);

    final boolean gms = GMS_CONSUMERS.contains(channelId);

    try {
      final Optional<ErrorResponse> errors = validateRequest(request);
      if (errors.isPresent()) {
        final ErrorResponse errorResponse = errors.get();
        log.error(msgMarker, "Validation failed = {}", errorResponse);
        finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
        sendReply(msgMarker, message, correlationId, channelId, finalResponse, FAILURE, HttpStatus.SC_BAD_REQUEST);
      } else {
        processRequest(msgMarker, request, correlationId, gms).onFailure(cause -> {
          final ErrorResponse response =
                  new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR), cause.getLocalizedMessage());
          sendReply(msgMarker, message, correlationId, channelId, response.toJson(), FAILURE,
                  HttpStatus.SC_INTERNAL_SERVER_ERROR);
        }).onSuccess(response -> {
          if (null == response || response.isEmpty()) {
            log.info(msgMarker, "Response is null or empty from database");
            final ErrorResponse errorResponse = new ErrorResponse(String.valueOf(HttpStatus.SC_NOT_FOUND),
                    "RECORD_NOT_FOUND");
            try {
              finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
            } catch (JsonProcessingException e) {
              throw new RuntimeException(e);
            }
            sendReply(msgMarker, message, correlationId, channelId, finalResponse, FAILURE, HttpStatus.SC_NOT_FOUND);
          } else {
            sendReply(msgMarker, message, correlationId, channelId, response, SUCCESS, HttpStatus.SC_OK);
          }
        });
      }
    } catch (Exception e) {
      log.info(msgMarker, "EXCEPTION OCCURRED WHILE PROCESSING REQUEST. DETAILS = {}", e.getLocalizedMessage());
      final ErrorResponse response =
              new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR), e.getLocalizedMessage());
      sendReply(msgMarker, message, correlationId, channelId, response.toJson(), FAILURE,
              HttpStatus.SC_INTERNAL_SERVER_ERROR);
    }
  }

  Future<JsonArray> processRequest(final Structured msgMarker, final JsonObject request, final String correlationId,
                                   final boolean isGms) {

    log.info(msgMarker, "Processing request {} for {}", request, correlationId);
    final Promise<JsonArray> promise = Promise.promise();

    final Future<Map<String, JsonObject>> demographicsAttributes = demoInfo(msgMarker, request, correlationId, isGms);
    final Future<Map<String, List<JsonObject>>> demoNameType = demoNameTypes(msgMarker, request, correlationId, isGms);
    final Future<Map<String, List<JsonObject>>> demoPhoneTypes = phoneTypes(msgMarker, request, correlationId, isGms);
    final Future<Map<String, JsonObject>> demoNetWork = networkDetails(msgMarker, request, correlationId, isGms);

    final JsonArray result = new JsonArray();

    CompositeFuture.all(demographicsAttributes, demoNameType, demoPhoneTypes, demoNetWork).onComplete(handler -> {
      if (handler.failed()) {
        promise.fail(handler.cause());
      } else {
        final Map<String, JsonObject> demo = demographicsAttributes.result();
        final Map<String, List<JsonObject>> demoNames = demoNameType.result();
        final Map<String, List<JsonObject>> demoPhones = demoPhoneTypes.result();
        final Map<String, JsonObject> demoNetwork = demoNetWork.result();
        if (demo == null) {
          log.info(msgMarker, "EMPTY RESPONSE FOR THE GIVEN REQUEST");
          promise.complete();
        } else {
          demo.forEach((key, contact) -> {
            contact.getJsonObject("demographicsAttributes").put("networkPrimaryDetails", demoNetwork == null
                    ? new JsonObject()
                    : demoNetwork.getOrDefault(key, new JsonObject()));
            contact.getJsonObject("demographicsAttributes").put("merchantNameType", demoNames == null
                    ? new ArrayList<>()
                    : demoNames.getOrDefault(key, new ArrayList<>()));
            contact.getJsonObject("demographicsAttributes").put("merchantTelephoneType", demoPhones == null
                    ? new ArrayList<>()
                    : demoPhones.getOrDefault(key, new ArrayList<>()));
            result.add(contact);
            if (demo.size() == result.size()) {
              log.info(msgMarker, "Combined the result");
              decryptResponse(result, msgMarker).onComplete(response -> {
                if (response.succeeded()) {
                  promise.complete(response.result());
                } else {
                  log.info(msgMarker, "FAILED TO DECRYPT. DETAILS  = {}", response.cause().getLocalizedMessage());
                  promise.fail("FAILED TO DECRYPT");
                }
              });
            }
          });
        }
      }
    });
    return promise.future();
  }

  Future<Map<String, JsonObject>> demoInfo(final Structured msgMarker, final JsonObject request,
                                           final String correlationId, final boolean value) {

    log.info(msgMarker, "Retrieving demographics Information");
    final Promise<Map<String, JsonObject>> promise = Promise.promise();
    final DemographicsNewDetailDbAction contactDbAction = new DemographicsNewDetailDbAction(msgMarker);
    String query = value
            ? this.configResult.getString(DEMO).concat(INCLUDE_GMS)
            : this.configResult.getString(DEMO).concat(INCLUDE_GNS);
    contactDbAction.setParams(query, request)
            .onSuccess(ignored -> dataService.executePreparedQueryList(contactDbAction.query, contactDbAction.params,
                    DBA_NAME, 500, correlationId, msgMarker, contactRes -> {
                      if (contactRes.failed()) {
                        final Throwable cause = contactRes.cause();
                        log.error(msgMarker, "Failed to get business contacts: {}",
                                cause.getLocalizedMessage(), cause);
                        promise.fail(cause);
                      } else {
                        final HashMap<String, JsonObject> demoInfo = new HashMap<>();
                        if (!contactRes.result().isEmpty()) {
                          contactRes.result().forEach(obj -> {
                            JsonObject eachDemo = new JsonObject();
                            final DemographicsNewResponse contact;
                            try {
                              contact = objectMapper.readValue(obj.toString(), DemographicsNewResponse.class);
                              JsonObject eachObject = contact.toJson();
                              eachDemo.put("merchantIdentifier", eachObject.getString("merchantIdentifier"));
                              eachDemo.put("demographicsAttributes", eachObject);
                              demoInfo.put(contact.primaryKey(), eachDemo);
                            } catch (JsonProcessingException e) {
                              throw new RuntimeException(e);
                            }
                          });
                        } else {
                          log.info(msgMarker, "DEMO FOR PARAMS = {} IS EMPTY", contactDbAction.params);
                          promise.complete();
                        }
                        promise.complete(demoInfo);
                      }
                    }));
    return promise.future();
  }

  Future<Map<String, List<JsonObject>>> demoNameTypes(final Structured msgMarker, final JsonObject request,
                                                      final String correlationId, final boolean value) {

    log.info(msgMarker, "Retrieving demoNameTypes");
    Promise<Map<String, List<JsonObject>>> promise = Promise.promise();
    final DemographicsNewDetailDbAction demoNameDetail = new DemographicsNewDetailDbAction(msgMarker);
    String query = value
            ? this.configResult.getString(DEMO_NM).concat(INCLUDE_GMS)
            : this.configResult.getString(DEMO_NM).concat(INCLUDE_GNS);
    demoNameDetail.setParams(query, request)
            .onSuccess(ignored -> dataService.executePreparedQueryList(demoNameDetail.query, demoNameDetail.params,
                    DBA_NAME, 1500, correlationId, msgMarker, addressRes -> {
                      if (addressRes.failed()) {
                        final Throwable cause = addressRes.cause();
                        log.error(msgMarker, "Failed to get business contact addresses: {}",
                                cause.getLocalizedMessage(), cause);
                        promise.fail(cause);
                      } else {
                        final HashMap<String, List<JsonObject>> addresses = new HashMap<>();
                        if (!addressRes.result().isEmpty()) {
                          addressRes.result().forEach(obj -> {
                            final MerchantNameType demoName;
                            try {
                              demoName = objectMapper.readValue(obj.toString(), MerchantNameType.class);
                            } catch (JsonProcessingException e) {
                              throw new RuntimeException(e);
                            }
                            addresses.compute(demoName.primaryKey(), (key, oldValue) -> {
                              final List<JsonObject> newValue = oldValue != null ? oldValue : new ArrayList<>(20);
                              try {
                                newValue.add(demoName.toJson());
                              } catch (JsonProcessingException e) {
                                throw new RuntimeException(e);
                              }
                              return newValue;
                            });
                          });
                        } else {
                          log.info(msgMarker, "DEMO_NM FOR PARAMS = {} IS EMPTY", demoNameDetail.params);
                          promise.complete();
                        }
                        promise.complete(addresses);
                      }
                    }));
    return promise.future();
  }

  Future<Map<String, List<JsonObject>>> phoneTypes(final Structured msgMarker, final JsonObject request,
                                                   final String correlationId, final boolean value) {

    log.info(msgMarker, "Retrieving demographics phone types");
    Promise<Map<String, List<JsonObject>>> promise = Promise.promise();
    final DemographicsNewDetailDbAction phoneContact = new DemographicsNewDetailDbAction(msgMarker);
    String query = value
            ? this.configResult.getString(DEMO_PHONE).concat(INCLUDE_GMS)
            : this.configResult.getString(DEMO_PHONE).concat(INCLUDE_GNS);
    phoneContact.setParams(query, request)
            .onSuccess(ignored -> dataService.executePreparedQueryList(phoneContact.query, phoneContact.params,
                    DBA_NAME, 500, correlationId, msgMarker, resp -> {
                      if (resp.failed()) {
                        final Throwable cause = resp.cause();
                        log.error(msgMarker, "Failed to get previous contact details: {}",
                                cause.getLocalizedMessage(), cause);
                        promise.fail(cause);
                      } else {
                        final HashMap<String, List<JsonObject>> phoneTypeDetails = new HashMap<>();
                        if (!resp.result().isEmpty()) {
                          resp.result().forEach(obj -> {
                            final MerchantTelephoneType phoneDetails;
                            try {
                              phoneDetails = objectMapper.readValue(obj.toString(), MerchantTelephoneType.class);
                            } catch (JsonProcessingException e) {
                              throw new RuntimeException(e);
                            }
                            phoneTypeDetails.compute(phoneDetails.primaryKey(), (key, oldValue) -> {
                              final List<JsonObject> newValue = oldValue != null ? oldValue : new ArrayList<>(20);
                              try {
                                newValue.add(phoneDetails.toJson());
                              } catch (JsonProcessingException e) {
                                throw new RuntimeException(e);
                              }
                              return newValue;
                            });
                          });
                        } else {
                          log.info(msgMarker, "DEMO_PHONE DETAILS FOR PARAMS = {} IS EMPTY", phoneContact.params);
                          promise.complete();
                        }
                        promise.complete(phoneTypeDetails);
                      }
                    }));
    return promise.future();
  }

  Future<Map<String, JsonObject>> networkDetails(final Structured msgMarker, final JsonObject request,
                                                 final String correlationId, final boolean value) {

    log.info(msgMarker, "Retrieving demographics network details");
    Promise<Map<String, JsonObject>> promise = Promise.promise();
    final DemographicsNewDetailDbAction detailDbAction = new DemographicsNewDetailDbAction(msgMarker);
    String query = value
            ? this.configResult.getString(DEMO_NETWORK).concat(INCLUDE_GMS)
            : this.configResult.getString(DEMO_NETWORK).concat(INCLUDE_GNS);
    detailDbAction.setParams(query, request)
            .onSuccess(ignored -> dataService.executePreparedQueryList(detailDbAction.query, detailDbAction.params,
                    DBA_NAME, 500, correlationId, msgMarker, detailRes -> {
                      if (detailRes.failed()) {
                        final Throwable cause = detailRes.cause();
                        log.error(msgMarker, "Failed to get business contact details: {}",
                                cause.getLocalizedMessage(), cause);
                        promise.fail(cause);
                      } else {
                        final HashMap<String, JsonObject> details = new HashMap<>();
                        if (!detailRes.result().isEmpty()) {
                          JsonObject results = detailRes.result().getJsonObject(0);
                          final NetworkPrimaryDetails detail;
                          try {
                            detail = objectMapper.readValue(results.toString(), NetworkPrimaryDetails.class);
                            details.put(detail.primaryKey(), detail.toJson());
                          } catch (JsonProcessingException e) {
                            throw new RuntimeException(e);
                          }
                          promise.complete(details);
                        } else {
                          log.info(msgMarker, "DEMO_NETWORK DETAILS FOR PARAMS = {} IS EMPTY", detailDbAction.params);
                          promise.complete();
                        }
                      }
                    }));
    return promise.future();
  }

  void sendReply(final Structured msgMarker, final Message<JsonObject> message, final String correlationId,
                 final String channelId, final Object response, final String responseStatus,
                 final int statusCode) {

    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(MicrodoseConstants.ONE_DATA_CORRELATION_ID, correlationId)
            .addHeader(CONTENT_TYPE, CONTENT)
            .addHeader(MicrodoseConstants.HTTP_STATUS_CODE, String.valueOf(statusCode));

    log.info(msgMarker,
            "sorFunctionCall , sorCorrId={} , sorChannelId={} , sorResult={} , sorResourceName={} , sorStatusCode={}",
            correlationId,
            channelId,
            responseStatus,
            FUNCTION_NAME,
            statusCode);
    message.reply(response, options);
  }

  private Future<JsonArray> decryptResponse(JsonArray reply, Structured msgMarker) {
    Promise<JsonArray> decryptResponse = Promise.promise();
    List allPromises = new ArrayList<>();
    for (int i = 0; i < reply.size(); i++) {
      Promise<Boolean> eachPromise = Promise.promise();
      JsonObject eachObject = reply.getJsonObject(i).getJsonObject("demographicsAttributes");
      String taxNumber = eachObject.getString("taxNumber").isEmpty() ? "" : eachObject.getString("taxNumber");
      if (!taxNumber.isBlank()) {
        if (!taxNumber.isEmpty()) {
          decryptField(taxNumber, "PII_V2_FPE", null, msgMarker).onComplete(resp -> {
            if (resp.succeeded()) {
              eachObject.put("taxNumber", resp.result());
            } else {
              log.info(msgMarker, "FAILED TO DECRYPT");
              eachObject.put("taxNumber", "");
            }
          });
        }
      }
      String taxDetailNumber = eachObject.getString("merchantTaxDetailNumber").isEmpty()
              ? "" : eachObject.getString("merchantTaxDetailNumber");
      if (!taxDetailNumber.isBlank()) {
        if (!taxDetailNumber.isEmpty()) {
          decryptField(taxDetailNumber, "PII_V2_FPE", null, msgMarker).onComplete(resp -> {
            if (resp.succeeded()) {
              eachObject.put("merchantTaxDetailNumber", resp.result());
            } else {
              log.info(msgMarker, "FAILED TO DECRYPT");
              eachObject.put("merchantTaxDetailNumber", "");
            }
          });
        }
      }
      String irstaxNumber = eachObject.getString("iRSTaxNumber").isEmpty()
              ? "" : eachObject.getString("iRSTaxNumber");
      if (!irstaxNumber.isBlank()) {
        if (!irstaxNumber.isEmpty()) {
          decryptField(irstaxNumber, "PII_V2_FPE", null, msgMarker).onComplete(resp -> {
            if (resp.succeeded()) {
              eachObject.put("iRSTaxNumber", resp.result());
            } else {
              log.info(msgMarker, "FAILED TO DECRYPT");
              eachObject.put("iRSTaxNumber", "");
            }
          });
        }
      }
      String regisTaxIdentifier = eachObject.getString("registeredTaxIdentifier").isEmpty()
              ? "" : eachObject.getString("registeredTaxIdentifier");
      if (!regisTaxIdentifier.isBlank()) {
        if (!regisTaxIdentifier.isEmpty()) {
          decryptField(regisTaxIdentifier, "PII_V2_FPE", null, msgMarker).onComplete(resp -> {
            if (resp.succeeded()) {
              eachObject.put("registeredTaxIdentifier", resp.result());
            } else {
              log.info(msgMarker, "FAILED TO DECRYPT");
              eachObject.put("registeredTaxIdentifier", "");
            }
          });
        }
      }

      telephoneEncrypt(msgMarker, eachObject).onComplete(resp -> {
        if (resp.succeeded()) {
          eachPromise.complete();
          allPromises.add(eachPromise.future());
        } else {
          eachPromise.fail("FAIL TO DECRYPT TELEPHONE VALUES");
          allPromises.add(eachPromise.future());
        }
      });
    }
    CompositeFuture.all(allPromises).onComplete(resp -> {
      if (resp.succeeded()) {
        decryptResponse.complete(reply);
      } else {
        decryptResponse.fail("FAIL TO DECRYPT. REASON = " + resp.cause().getLocalizedMessage());
      }
    });
    return decryptResponse.future();
  }

  private Future<Boolean> telephoneEncrypt(Structured msgMarker, JsonObject eachObject) {
    Promise<Boolean> promise = Promise.promise();
    List<Future> allPromises = new ArrayList<>();
    JsonArray merchantTelephoneType = eachObject.getJsonArray("merchantTelephoneType");
    if (!merchantTelephoneType.isEmpty()) {
      IntStream.range(0, merchantTelephoneType.size()).forEach(j -> {
        Promise<Boolean> eachPromise = Promise.promise();
        JsonObject eachTelephoneType = merchantTelephoneType.getJsonObject(j);
        String telephoneNumber = eachTelephoneType.getString("telephoneNumber");
        if (!telephoneNumber.isBlank()) {
          if (!telephoneNumber.isEmpty()) {
            decryptField(telephoneNumber, "PII_V2_FPE", null, msgMarker).onComplete(resp -> {
              if (resp.succeeded()) {
                eachTelephoneType.put("telephoneNumber", resp.result());
                eachPromise.complete(true);
              } else {
                log.info(msgMarker, "FAILED TO DECRYPT");
                eachTelephoneType.put("telephoneNumber", "");
                eachPromise.complete(true);
              }
              allPromises.add(eachPromise.future());
            });
          }
        }
      });

      CompositeFuture.all(allPromises).onComplete(resp -> {
        if (resp.succeeded()) {
          promise.complete(true);
        } else {
          promise.fail("FAIL TO DECRYPT. REASON = " + resp.cause().getLocalizedMessage());
        }
      });
    } else {
      log.info(msgMarker, "EMPTY RESPONSE FOR TELEPHONES FROM DB");
      promise.complete(true);
    }
    return promise.future();
  }

  private Optional<ErrorResponse> validateRequest(final JsonObject request) {

    if (null == request || request.isEmpty()) {
      return Optional.of(new ErrorResponse(DemographicsConstants.REQUIRED_ATTRIBUTE,
              "Empty Request. merchantIdentifierList is required"));
    } else if (!request.getJsonObject(CORE_ATTRIBUTES).containsKey(MERCHANT_IDENTIFIER_LIST)) {
      return Optional.of(new ErrorResponse(DemographicsConstants.REQUIRED_ATTRIBUTE,
              MERCHANT_IDENTIFIER_LIST + " is required"));
    }
    JsonArray array = request.getJsonObject(CORE_ATTRIBUTES).getJsonArray(MERCHANT_IDENTIFIER_LIST);
    if (array.size() == 0) {
      return Optional.of(new ErrorResponse(DemographicsConstants.REQUIRED_ATTRIBUTE,
              MERCHANT_IDENTIFIER_LIST + " should contains valid values"));
    }
    return Optional.empty();
  }

  private Future<String> decryptField(final String key, final String bankFormat,
                                      final String tweak, final Structured msgMarker) {
    Promise<String> promise = Promise.promise();
    try {
      encrConfig = new JsonObject()
              .put("KEY_IDENTIFIER", decryptConfig.getString("KEY_IDENTIFIER"))
              .put("PROVIDER", decryptConfig.getString("PROVIDER"))
              .put("KMS_CBIS_ENDPOINT", decryptConfig.getString("KMS_CBIS_ENDPOINT"))
              .put("KMS_CBIS_TOKEN_ENDPOINT", decryptConfig.getString("KMS_CBIS_TOKEN_ENDPOINT"))
              .put("KMS_CBIS_CLIENT_ID", decryptConfig.getString("KMS_CBIS_CLIENT_ID"))
              .put("KMS_CBIS_CLIENT_SECRET", decryptConfig.getString("KMS_CBIS_CLIENT_SECRET"))
              .put("KMS_APP_CAR_ID", decryptConfig.getString("KMS_APP_CAR_ID"));
      Properties properties = new Properties();
      encrConfig.forEach((data) -> {
        properties.put(data.getKey(), data.getValue());
      });
      KeyHandleFPE kh = new KeyHandleFPE(encrConfig.getString("KEY_IDENTIFIER"));
      CryptoFPE cryptoFpeUtil = new CryptoFPE(properties, "MODUS-" + null);
      final String value = cryptoFpeUtil.decrypt(key, kh, bankFormat, tweak);
      if (value == null) {
        log.info(msgMarker, "VALUE IS NOT DECRYPTED. SO RETRY BY ADDING PATH");
        encrConfig = new JsonObject()
                .put("KEY_IDENTIFIER", decryptConfig.getString("KEY_IDENTIFIER"))
                .put("PROVIDER", decryptConfig.getString("PROVIDER"))
                .put("KMS_CBIS_ENDPOINT", decryptConfig.getString("KMS_CBIS_ENDPOINT"))
                .put("KMS_CBIS_TOKEN_ENDPOINT", decryptConfig.getString("KMS_CBIS_TOKEN_ENDPOINT"))
                .put("KMS_CBIS_CLIENT_ID", decryptConfig.getString("KMS_CBIS_CLIENT_ID"))
                .put("KMS_CBIS_CLIENT_SECRET", decryptConfig.getString("KMS_CBIS_CLIENT_SECRET"))
                .put("SO_FILE_PATH", "/main/resources/libcrypto")
                .put("KMS_APP_CAR_ID", decryptConfig.getString("KMS_APP_CAR_ID"));
        Properties properties1 = new Properties();
        encrConfig.forEach((data) -> {
          properties1.put(data.getKey(), data.getValue());
        });
        KeyHandleFPE keyhand = new KeyHandleFPE(encrConfig.getString("KEY_IDENTIFIER"));
        CryptoFPE cryptoFpeUtils = new CryptoFPE(properties1, "MODUS-" + null);
        final String values = cryptoFpeUtils.decrypt(key, keyhand, bankFormat, tweak);
        promise.complete(values);
      } else {
        promise.complete(value);
      }
    } catch (HiPEDException ex) {
      log.info(msgMarker, "Exception during decrypting the value. Details : " + ex.getLocalizedMessage());
      promise.fail("FAILED TO DECRYPT");
    }
    return promise.future();
  }
}
