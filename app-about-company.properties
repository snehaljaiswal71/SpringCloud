public void executePreparedQuery(
      String sql,
      JsonArray param,
      String dbName,
      Integer queryTimeout,
      String correlationId,
      Marker marker,
      Handler<AsyncResult<JsonObject>> resultHandler) {
    requireNonNull(sql, SQL_IS_REQUIRED_AND_MISSING);
    requireNonNull(param, PARAM_IS_REQUIRED_AND_MISSING);
    requireNonNull(dbName, "dbName is required and missing");

    Promise<JsonObject> promise = Promise.promise();
    JsonArray list = new JsonArray();
    final long startForCon = System.currentTimeMillis();

    try {
      for (Object obj : param.getList()) {
        if (obj instanceof Instant) {
          try {
            OffsetDateTime offsetDate = OffsetDateTime.ofInstant((Instant) obj, ZoneOffset.UTC);
            list.add(offsetDate);
          } catch (Exception e) {
            list.add(obj);
          }
        } else {
          list.add(obj);
        }
      }

      dbUtil.getConnection(
          dbName,
          correlationId,
          marker,
          connRes -> {
            if (connRes.succeeded()) {
              try {
                SQLConnection conn = connRes.result();
                SQLOptions options = new SQLOptions();
                options.setQueryTimeout(queryTimeout);

                conn.setOptions(options);
                final long endForConStartForQuery = System.currentTimeMillis();

                conn.queryWithParams(
                    sql,
                    list,
                    ar -> {
                      try {
                        conn.close();
                        long endForQuery = System.currentTimeMillis();
                        if (ar.succeeded()) {
                          LOGGER.info(
                              marker,
                              "{} : CorrelationId: {}, executePreparedQuery method execution, Total time to query execute: {} ms, to get db connection: {} ms, Response size: {}, Query: {}",
                              DB_JAR,
                              correlationId,
                              ((endForQuery - endForConStartForQuery)),
                              (endForConStartForQuery - startForCon),
                              ar.result() != null
                                  ? (ar.result().getRows() != null
                                      ? (ar.result().getRows().size())
                                      : 0)
                                  : 0,
                              sql.length() > 50 ? sql.substring(0, 50) : sql);
                          if (ar.result() != null
                              && ar.result().getRows() != null
                              && ar.result().getRows().size() > 0) {
                            promise.complete(ar.result().getRows().get(0));
                          } else {
                            LOGGER.debug(
                                marker,
                                "DB_ JAR : CorrelationId: {}, Update record ignored due to old value trying to override, Query: {} , Params: {}",
                                correlationId,
                                sql.length() > 38 ? sql.substring(18, 38) : sql,
                                param);
                            promise.complete(new JsonObject());
                          }
                        } else {
                          LOGGER.error(
                              marker,
                              "{} : CorrelationId: {}, Error while executing prepared query executePreparedQuery() for record count: {}, Total time to execute: {} ms, to get db connection: {} ms, Reason: {}, Cause: {}, Query: {}",
                              DB_JAR_ERROR,
                              correlationId,
                              list.size(),
                              ((endForQuery - endForConStartForQuery)),
                              (endForConStartForQuery - startForCon),
                              ar.cause() != null
                                  ? ar.cause().getLocalizedMessage()
                                  : "Cause is null",
                              ExceptionUtils.getStackTrace(ar.cause()),
                              sql.length() > 100 ? sql.substring(0, 100) : sql);

                          promise.fail(ar.cause());
                        }
                      } catch (Exception e) {
                        LOGGER.error(
                            marker,
                            "CorrelationId: {}, Exception while running queryWithParams in executePreparedQuery method, Reason: {}, Trace: {}",
                            correlationId,
                            e.getLocalizedMessage(),
                            ExceptionUtils.getStackTrace(e));
                        promise.fail(e);
                      }
                    });
              } catch (Exception e) {
                connRes.result().close();
                LOGGER.error(
                    marker,
                    "CorrelationId: {}, Exception while processing result in executePreparedQuery method, Reason: {}, Trace: {}",
                    correlationId,
                    e.getLocalizedMessage(),
                    ExceptionUtils.getStackTrace(e));
                promise.fail(e);
              }
            } else {
              LOGGER.error(
                  marker,
                  "{} : CorrelationId: {}, Error while getting connections from PG DB executePreparedQuery(). time taken while tried to get connection: {} ms, Reason: {}, Cause: {}, Query: {}",
                  DB_JAR_ERROR,
                  correlationId,
                  System.currentTimeMillis() - startForCon,
                  connRes.cause() != null ? connRes.cause().getLocalizedMessage() : "Cause is null",
                  connRes.cause(),
                  sql);
              promise.fail(connRes.cause());
            }
          });
    } catch (Exception e) {
      LOGGER.error(
          marker,
          "{} : CorrelationId: {}, Exception in executePreparedQuery : Reason: {}, Trace: {}",
          DB_JAR_ERROR,
          correlationId,
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
      promise.fail(e);
    }
    promise
        .future()
        .onComplete(
            ig -> {
              resultHandler.handle(promise.future());
            });
  }
