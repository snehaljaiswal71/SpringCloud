package com.axp.microdose.unified.merchant.read.demographics.sor;

import com.aexp.gmdl.db.component.InitializeDBComponent;
import com.aexp.gmdl.db.component.service.DbAction;
import com.aexp.gmdl.db.component.service.TransactionalReferenceDataService;
import com.axp.logging.schema.v0_1.Application;
import com.axp.logging.schema.v0_1.Structured;
import com.axp.microdose.commons.MicrodoseConstants;
import com.axp.microdose.data.AbstractMicrodoseVerticle;
import com.axp.microdose.unified.merchant.read.demographics.data.DemographicsDetailDbAction;
import com.axp.microdose.unified.merchant.read.demographics.util.ConfigRetrieverHelper;
import com.axp.microdose.unified.merchant.read.demographics.util.DemographicsConstants;
import com.axp.microdose.unified.merchant.read.demographics.util.DemographicsResponse;
import com.axp.microdose.vertx.logging.Logger;
import com.axp.microdose.vertx.logging.LoggerFactory;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.http.HttpStatus;

import java.io.InputStream;
import java.util.*;
import java.util.stream.IntStream;

import static com.axp.microdose.unified.merchant.read.demographics.util.DemographicsConstants.*;

public class ReadUnifiedMerchantDemographicsVerticle extends AbstractMicrodoseVerticle {

  private static final Logger log = LoggerFactory.getLogger(ReadUnifiedMerchantDemographicsVerticle.class);
  private Application application;
  private Structured classMarker;
  private TransactionalReferenceDataService txReferenceDataService;
  private JsonObject configResult;
  private Properties queryProperties;
  private static final String DB_CONNECTION_LOG_MESSAGE = "App_NAME: ReadUnifiedMerchantDemographics.sor.v1";
  private ObjectMapper objectMapper;
  private static final String FUNCTION_NAME = "ReadUnifiedMerchantDemographics.sor.v1";

  @Override
  public void start(final Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    objectMapper = new ObjectMapper();
    application = getApplication(ReadUnifiedMerchantDemographicsVerticle.class);
    classMarker = getClassMarker(application);
    log.info(classMarker, "Starting {}", getClass().getSimpleName());

    ConfigRetrieverHelper.CONFIGURATION_RETRIEVER
      .withJsonObject(config())
      .withEnvVariablesStore()
      .getConfig(vertx)
      .onSuccess(configResult -> {
        log.info(classMarker, "{} has started", getClass().getSimpleName());
        this.configResult = configResult;
        try {
          log.info(classMarker, "Before db initialized");
          InitializeDBComponent.initializeDBComponent(vertx, this.configResult, classMarker)
            .onSuccess(res -> {
              this.txReferenceDataService = TransactionalReferenceDataService.create(
                this.vertx,
                this.configResult.getJsonObject(MicrodoseConstants.LAMBDA_CONFIG, new JsonObject()),
                TransactionalReferenceDataService.DBType.PG_DB, classMarker);
              vertx.eventBus().consumer(getFunctionAddress(), this::handle);
              startPromise.complete();
            })
            .onFailure(err -> {
              log.error(classMarker, "ERROR while starting verticle,cause: {}", err.getLocalizedMessage(), err);
              startPromise.fail(err.toString());
            });
        } catch (Exception e) {
          log.error(classMarker, "Something went wrong", e);
          throw new RuntimeException(e);
        }
      });
  }

  @Override
  public void stop(Promise<Void> stopPromise) {
    try {
      super.stop(stopPromise);
      log.info(classMarker, "stopped the verticle");
    } catch (Exception e) {
      log.error(classMarker, "ERROR : {} :  Failed to stop verticle, Error: {}, Trace: {}",
        FUNCTION_NAME, e.getLocalizedMessage(),
        ExceptionUtils.getStackFrames(e));
      stopPromise.fail(e.getLocalizedMessage());
    }
  }

  void handle(final Message<JsonObject> message) {

    final Structured msgMarker = getMessageMarker(message, application);
    final String correlationId = message.headers().get(MicrodoseConstants.ONE_DATA_CORRELATION_ID);
    final String channelId =
      Optional.ofNullable(message.headers().get(DemographicsConstants.CHANNEL))
        .orElse(DemographicsConstants.DEFAULT_CHANNEL).toUpperCase();
    final JsonObject request = message.body();
    String queryType;
    if ("MSP_SETS".equalsIgnoreCase(channelId)) {
      queryType = "MSP_SETS";
      request.put("MSP_SETS", request.getJsonObject("coreAttributes").getJsonArray("merchantIdentifierList"));
    } else {
      queryType = channelId != null ? (GMS_CONSUMERS.contains(channelId) ? "GMS" : "GNS") : "GNS";
    }
    JsonArray finalResponse = new JsonArray();
    String fileName = "demographicQueries.properties";
    this.queryProperties = new Properties();
    log.info(classMarker, "Loaded query from : {} file", fileName);
    try {
      final InputStream inputStream = getClass().getClassLoader().getResourceAsStream(fileName);
      queryProperties.load(inputStream);
    } catch (final Exception error) {
      log.error(classMarker, "Failed to load property file: {}", fileName, error);
      message.fail(500, "Unable to process request");
    }

    String userId = configResult.getJsonObject("postgres-config", new JsonObject())
      .getJsonObject("gcharcore", new JsonObject())
      .getJsonObject("primary", new JsonObject())
      .getString("user");
    log.info(msgMarker, "New Request with channel id = {} , SOR , {}, correlation id = {} , request = {}, userId = {}",
            channelId, FUNCTION_NAME, correlationId, request, userId);
    logFunctionCallReceived(msgMarker, request, channelId);
    try {
      JsonArray settlementSetSeNumbers = new JsonArray();
      final Optional<ErrorResponse> errors = validateRequest(request);
      if (errors.isPresent()) {
        final ErrorResponse errorResponse = errors.get();
        log.error(msgMarker, "Validation failed: {}", errorResponse);
        finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
        sendReply(message, finalResponse, correlationId, channelId, DemographicsConstants.FAILURE,
          HttpStatus.SC_BAD_REQUEST, msgMarker);
      } else {
        DbAction dbAction = new DemographicsDetailDbAction(msgMarker, channelId);
        dbAction.setParams(queryProperties.getProperty(queryType), request).onSuccess(ig -> {
          log.info(msgMarker, "Db jar call started.");
          log.info(msgMarker, "QUERY IS : {} AND PARAMS ARE : {}", dbAction.query, dbAction.params);
          txReferenceDataService.executePreparedQueryList(dbAction.query, dbAction.params, DBA_NAME,
            8000, correlationId + " " + DB_CONNECTION_LOG_MESSAGE, msgMarker, reply -> {
              log.info(msgMarker, "Db jar call completed.");
              if (reply.succeeded()) {
                log.info(msgMarker, "Db jar call succeeded");
                final JsonArray response = reply.result();
                if (response == null || response.isEmpty()) {
                  log.info(msgMarker, "Response is null or empty from database");
                  final ErrorResponse errorResponse = new ErrorResponse(String.valueOf(HttpStatus.SC_NOT_FOUND),
                    RECORD_NOT_FOUND);
                  try {
                    finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
                  } catch (JsonProcessingException e) {
                    throw new RuntimeException(e);
                  }
                  sendReply(message, finalResponse, correlationId, channelId, DemographicsConstants.FAILURE,
                    HttpStatus.SC_NOT_FOUND, msgMarker);
                } else {
                  log.info(msgMarker, "DB jar responded successfully and about to map response");
                  Map<String, JsonArray> demographicsResponse = new HashMap<>();
                  response.forEach(object -> {
                    DemographicsResponse eachResponse = null;
                    try {
                      eachResponse = new ObjectMapper().readValue(object.toString(),
                        DemographicsResponse.class);
                    } catch (JsonProcessingException e) {
                      log.info(msgMarker, "Response mapping failed");
                      final ErrorResponse errorResponse =
                        new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR),
                        "Internal error : ReadUnifiedMerchantDemographics.sor.v1 : response mapping failed");
                      try {
                        finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
                      } catch (JsonProcessingException ex) {
                        throw new RuntimeException(ex);
                      }

                      sendReply(message, finalResponse, correlationId, channelId, DemographicsConstants.FAILURE,
                        HttpStatus.SC_INTERNAL_SERVER_ERROR, msgMarker);
                      e.printStackTrace();
                    }
                    if (null != eachResponse) {
                      try {
                        JsonObject eachObject = new JsonObject(objectMapper.writeValueAsString(eachResponse));
                        JsonObject newObject = new JsonObject();
                        newObject = getEntries(requiredFields.get(channelId), eachObject, newObject);
                        String merchantId = newObject.getString(MERCHANT_IDENTIFIER).trim();
                        settlementSetSeNumbers.add(merchantId);
                        if (demographicsResponse.containsKey(merchantId)) {
                          demographicsResponse.put(merchantId, demographicsResponse.get(merchantId).add(newObject));
                        } else {
                          demographicsResponse.put(merchantId, new JsonArray().add(newObject));
                        }
                      } catch (Exception e) {
                        log.error(msgMarker, "Required fields mapping failed. Reason : {}", e.getLocalizedMessage());
                        final ErrorResponse errorResponse =
                          new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR),
                            "Internal error : ReadUnifiedMerchantDemographics.sor.v1 "
                                    + ": required fields mapping failed");
                        try {
                          finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
                        } catch (JsonProcessingException ex) {
                          throw new RuntimeException(ex);
                        }
                      }
                    }
                  });
                  JsonArray requestArray;
                  if ("MSP_SETS".equalsIgnoreCase(channelId)) {
                    requestArray = settlementSetSeNumbers;
                  } else {
                    requestArray = request.getJsonObject(CORE_ATTRIBUTES)
                            .getJsonArray("merchantIdentifierList", new JsonArray());
                  }
                  JsonArray finalRequestArray = requestArray;
                  IntStream.range(0, requestArray.size()).mapToObj(i -> new JsonObject()
                                  .put("merchantIdentifier", finalRequestArray.getString(i).trim())
                                  .put("demographicsAttributes", new JsonArray().add(new JsonObject()
                                                  .put("merchantIdentifier", finalRequestArray.getString(i).trim())
                                                  .put("settlementSetType",
                                                          demographicsResponse
                                                                  .getOrDefault(finalRequestArray.getString(i),
                                                                          new JsonArray())))))
                          .forEach(finalResponse::add);
                  sendReply(message, finalResponse, correlationId, channelId, DemographicsConstants.SUCCESS,
                          HttpStatus.SC_OK, msgMarker);
                }
              } else {
                String errorMessage = reply.cause() != null ? reply.cause().getLocalizedMessage()
                  : "No error message available";
                log.error(msgMarker, "Db jar call failed. Reason : {}", errorMessage);
                final ErrorResponse errorResponse =
                  new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR),
                          "Internal error : ReadUnifiedMerchantDemographics.sor.v1 : "
                    + errorMessage);
                try {
                  finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
                } catch (JsonProcessingException e) {
                  throw new RuntimeException(e);
                }

                sendReply(message, finalResponse, correlationId, channelId, DemographicsConstants.FAILURE,
                  HttpStatus.SC_INTERNAL_SERVER_ERROR, msgMarker);
              }
            });
        });
      }
    } catch (Exception e) {
      String errorMessage = e.getLocalizedMessage() != null ? e.getLocalizedMessage() : "No error message available";
      log.error(msgMarker, "Internal server error: {}", errorMessage);
      final ErrorResponse errorResponse = new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR),
        "Internal error : ReadUnifiedMerchantDemographics.sor.v1 : " + errorMessage);
      try {
        finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
      } catch (JsonProcessingException ex) {
        throw new RuntimeException(ex);
      }
      sendReply(message, finalResponse, correlationId, channelId, DemographicsConstants.FAILURE,
        HttpStatus.SC_INTERNAL_SERVER_ERROR, msgMarker);
    }
  }

  private JsonObject getEntries(List<String> requiredFields, JsonObject eachObject, JsonObject newObject) {

    if (requiredFields != null) {
      for (String requiredField : requiredFields) {
        newObject.put(requiredField, eachObject.getValue(requiredField));
      }
    } else {
      newObject = eachObject;
    }
    return newObject;
  }

  private void sendReply(final Message<JsonObject> message, final JsonArray reply, final String correlationId,
                         final String channelId, final String responseStatus, final int statusCode,
                         final Structured msgMarker) {

    final DeliveryOptions options = new DeliveryOptions().addHeader(MicrodoseConstants.ONE_DATA_CORRELATION_ID,
        correlationId).addHeader(MicrodoseConstants.HTTP_STATUS_CODE, String.valueOf(statusCode))
      .addHeader(org.apache.http.protocol.HTTP.CONTENT_TYPE, CONTENT_TYPE);

    log.info(msgMarker, "sorFunctionCall , sorCorrId={} , sorChannelId={} , " + "sorResult={} , sorResourceName={} , "
      + "sorStatusCode={}", correlationId, channelId, responseStatus, SOR_FUNCTION, statusCode);
    message.reply(reply, options);
  }

  private Optional<ErrorResponse> validateRequest(final JsonObject request) {

    if (null == request || request.isEmpty()) {
      return Optional.of(new ErrorResponse(DemographicsConstants.REQUIRED_ATTRIBUTE,
              "Empty Request. merchantIdentifierList is required"));
    } else if (!request.getJsonObject(CORE_ATTRIBUTES).containsKey(MERCHANT_IDENTIFIER_LIST)) {
      return Optional.of(new ErrorResponse(DemographicsConstants.REQUIRED_ATTRIBUTE,
              MERCHANT_IDENTIFIER_LIST + " is required"));
    }
    JsonArray array = request.getJsonObject(CORE_ATTRIBUTES).getJsonArray(MERCHANT_IDENTIFIER_LIST);
    if (array.size() == 0) {
      return Optional.of(new ErrorResponse(DemographicsConstants.REQUIRED_ATTRIBUTE,
              MERCHANT_IDENTIFIER_LIST + " should contains valid values"));
    }
    return Optional.empty();
  }

  private void logFunctionCallReceived(Structured msgMarker, JsonObject request, String channelId) {
    try {
      StringBuilder outputString = new StringBuilder();
      JsonObject coreAttributes = request.getJsonObject(CORE_ATTRIBUTES);
      JsonObject demographicAttributes;
      outputString.append(SOR_FUNCTION + " : Received request : Channel: " + channelId + ", Key : [");
      outputString.append("[");
      for (int i = 0; i < coreAttributes.getJsonArray(MERCHANT_IDENTIFIER_LIST).size(); i++) {
        outputString.append(coreAttributes.getJsonArray(MERCHANT_IDENTIFIER_LIST).getString(i));
        if (i < coreAttributes.getJsonArray(MERCHANT_IDENTIFIER_LIST).size() - 1)
          outputString.append(",");
      }
      if (coreAttributes.containsKey(ACQUIRING_INSTITUTION_IDENTIFICATION_NUMBER)) {
        String acquiringInstitutionIdentificationNumber =
                coreAttributes.getString(ACQUIRING_INSTITUTION_IDENTIFICATION_NUMBER, "");
        if (acquiringInstitutionIdentificationNumber != null
                || !acquiringInstitutionIdentificationNumber.isEmpty()) {
          outputString.append(coreAttributes.getString(ACQUIRING_INSTITUTION_IDENTIFICATION_NUMBER));
        }
      }
      if (coreAttributes.containsKey(SOURCE_SYSTEM_IDENTIFIER)) {
        String sourceSystemIdentifier =
                coreAttributes.getString(SOURCE_SYSTEM_IDENTIFIER, "");
        if (sourceSystemIdentifier != null || !sourceSystemIdentifier.isEmpty()) {
          outputString.append(coreAttributes.getString(SOURCE_SYSTEM_IDENTIFIER));
        }
      }
      if (coreAttributes.containsKey(BUSINESS_CENTER_CODE)) {
        String businessCenterCode =
                coreAttributes.getString(BUSINESS_CENTER_CODE, "");
        if (businessCenterCode != null
                || !businessCenterCode.isEmpty()) {
          outputString.append(coreAttributes.getString(BUSINESS_CENTER_CODE));
        }
      }
      outputString.append("]:[");

      for (int i = 0; i < request.getJsonArray(RESPONSE_FILTER).size(); i++) {
        outputString.append(request.getJsonArray(RESPONSE_FILTER).getString(i));
        if (i < request.getJsonArray(RESPONSE_FILTER).size() - 1)
          outputString.append(",");
      }
      outputString.append("]]");

      if (request.containsKey(DEMOGRAPHIC_ATTRIBUTES)) {
        outputString.append(", Demographics : [");
        demographicAttributes = request.getJsonObject(DEMOGRAPHIC_ATTRIBUTES, new JsonObject());
        if (demographicAttributes != null || !demographicAttributes.isEmpty()) {
          outputString.append("[");
          if (demographicAttributes.containsKey(SET_TYPE_CODE)) {
            String settlementAccountTypeCode =
                    demographicAttributes.getString(SET_TYPE_CODE, "");
            if (settlementAccountTypeCode != null
                    || !settlementAccountTypeCode.isEmpty()) {
              outputString.append(coreAttributes.getString(SET_TYPE_CODE));
            }
          }
          outputString.append("]]");
        }
      }
      msgMarker.put(SOR_FUNCTION_ADDRESS, SOR_FUNCTION);
      msgMarker.put(CHANNEL_ID, channelId);
      log.info(msgMarker, outputString.toString());
    } catch (Exception e) {
      msgMarker.put(SOR_FUNCTION_ADDRESS, SOR_FUNCTION);
      msgMarker.put(CHANNEL_ID, channelId);
      log.info(msgMarker, "{} : Received request : Channel: {}", SOR_FUNCTION, channelId);
    }
  }
}
