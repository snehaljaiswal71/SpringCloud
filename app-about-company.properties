package com.aexp.gmdl.db.component.verticle;

import static com.aexp.gmdl.db.component.constants.AppConstants.*;

import com.aexp.gmdl.db.component.service.TransactionalReferenceDataService;
import com.aexp.gmdl.db.component.util.MessageMarker;
import io.vertx.core.*;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;

public class DBHealthCheckVerticle extends AbstractVerticle {

  private static final Logger LOGGER = LoggerFactory.getLogger(DBHealthCheckVerticle.class);

  private static final String ADDRESS = "db.hc.eb.svc";
  Vertx vertx;

  public Future<Void> init(
      Vertx vertx,
      JsonObject config,
      TransactionalReferenceDataService transactionalReferenceDataService,
      Marker classMarker) {
    LOGGER.debug(classMarker, "DB_JAR : Initializing DBHealthCheckVerticle");

    Promise<Void> startPromise = Promise.promise();
    try {

      JsonObject commonConfig = config.getJsonObject("common");
      Boolean healthCheckEnabled =
          commonConfig != null && commonConfig.getBoolean(HEATH_CHECK_SSL_ENABLED, false);

      if (healthCheckEnabled.equals(Boolean.TRUE)) {
        this.vertx = vertx;
        this.vertx.eventBus().consumer(ADDRESS, this::handle);
        startPromise.complete();
      } else {
        LOGGER.info(classMarker, "{} : NOT DEPLOYED : DBHealthCheck is disabled", DB_JAR);
        startPromise.complete();
      }
    } catch (Exception e) {
      LOGGER.error(classMarker, "{} : Error while deploying DBHealthCheck Verticle", DB_JAR_ERROR);
      startPromise.complete();
    }
    return startPromise.future();
  }
  /*
  * Writing the healthcheck logic as per the below request format in form of a JsonObject
  * {"sqlQuery":"query-to-be-run"
  * "dbConfig":
  * {"url" : "DB-URL",
    "driver_class" : "com.ibm.db2.jcc.DB2Driver",
    "initial_pool_size" : 1,
    "max_pool_size" : 15,
    "min_pool_size" : 1,
    "user" : "user-name",
    "password" : "password",
    "acquire_retry_attempts" : 3,
    "max_idle_time" : 20,
    "break_after_retry_failure":true
    * }}*/

  // TODO Add end point.
  private void handle(Message<JsonObject> message) {
    JsonObject requestBody = message.body();
    MultiMap headers = message.headers();

    MessageMarker messageMarker = MessageMarker.getMessageMarker(headers);

    JsonObject dbConfig = requestBody.getJsonObject("dbConfig");
    JDBCClient jdbcClient = JDBCClient.createShared(vertx, dbConfig);
    jdbcClient.getConnection(
        handler -> {
          if (handler.succeeded()) {
            LOGGER.info(
                messageMarker,
                "DB_JAR : Connection to the DB - {} succeeded!",
                dbConfig.getString("url"));
            // testing if the query run is successful or not.
            handler
                .result()
                .query(
                    requestBody.getString("sqlQuery"),
                    queryHandler -> {
                      if (queryHandler.succeeded()) {
                        handler.result().close();
                        LOGGER.info(
                            messageMarker,
                            "DB_JAR : Query - {} - to the DB succeeded!",
                            requestBody.getString("sqlQuery"));
                        message.reply(
                            new JsonObject()
                                .put("connection-status", "Success")
                                .put("query-run-status", "Success"));
                      } else {
                        LOGGER.error(
                            messageMarker,
                            "{} : Query - {} - to the DB failed with error - {}",
                            DB_JAR_ERROR,
                            requestBody.getString("sqlQuery"),
                            queryHandler.cause());
                        message.reply(
                            new JsonObject()
                                .put("connection-status", "Success")
                                .put("query-run-status", "Failure")
                                .put("error-details", queryHandler.cause()));
                      }
                    });
          } else {
            LOGGER.error(
                messageMarker,
                "{} : Connection to the DB - {} failed with Reason: {}, Trace: {}",
                DB_JAR_ERROR,
                dbConfig.getString("url"),
                handler.cause() != null ? handler.cause().getLocalizedMessage() : "Cause is null",
                handler.cause());
            message.reply(
                new JsonObject()
                    .put("connection-status", "Failure")
                    .put("query-run-status", "")
                    .put("error-details", handler.cause()));
          }
        });
  }
}
