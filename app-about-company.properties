ublic class ReadUnifiedMerchantDemographicsNewVerticle extends AbstractMicrodoseVerticle {

  private static final Logger log = LoggerFactory.getLogger(ReadUnifiedMerchantDemographicsNewVerticle.class);
  private Application application;
  private Structured classMarker;
  private TransactionalReferenceDataService dataService;
  private JsonObject configResult;
  private ObjectMapper objectMapper;
  private static final String FUNCTION_NAME = "ReadUnifiedMerchantDemographics.sor.v2";
  private JsonObject decryptConfig;
  private Structured msgMarker;
  private JsonObject encrConfig;

  @Override
  public void start(final Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    objectMapper = new ObjectMapper();
    application = getApplication(ReadUnifiedMerchantDemographicsNewVerticle.class);
    classMarker = getClassMarker(application);
    log.info(classMarker, "Starting {}", getClass().getSimpleName());
    decryptConfig = config().getJsonObject(LAMBDA_CONFIG).getJsonObject(DECRYPTION);

    ConfigRetrieverHelper.CONFIGURATION_RETRIEVER
            .withJsonObject(config())
            .withPropertiesFileStore("DemographicQueryV3.properties")
            .withEnvVariablesStore()
            .getConfig(vertx)
            .onSuccess(configResult -> {
              log.info(classMarker, "{} has started", getClass().getSimpleName());
              this.configResult = configResult;
              try {
                log.info(classMarker, "Before db initialized");
                InitializeDBComponent.initializeDBComponent(vertx, this.configResult, classMarker)
                        .onSuccess(res -> {
                          this.dataService = TransactionalReferenceDataService.create(
                                  this.vertx,
                                  this.configResult.getJsonObject(LAMBDA_CONFIG, new JsonObject()),
                                  TransactionalReferenceDataService.DBType.PG_DB, classMarker);
                          vertx.eventBus().consumer(getFunctionAddress(), this::handle);
                          startPromise.complete();
                        })
                        .onFailure(err -> {
                          log.error(classMarker, "ERROR while starting verticle,cause: {}",
                                  err.getLocalizedMessage(), err);
                          startPromise.fail(err.toString());
                        });
              } catch (Exception e) {
                log.error(classMarker, "Something went wrong", e);
                throw new RuntimeException(e);
              }
            });
  }

  @Override
  public void stop(Promise<Void> stopPromise) {
    try {
      super.stop(stopPromise);
      log.info(classMarker, "Stopped the " + FUNCTION_NAME + " verticle");
    } catch (Exception e) {
      log.error(classMarker, "ERROR : {} :  Failed to stop verticle, Error: {}, Trace: {}",
              FUNCTION_NAME, e.getLocalizedMessage(),
              ExceptionUtils.getStackFrames(e));
      stopPromise.fail(e.getLocalizedMessage());
    }
  }

  void handle(final Message<JsonObject> message) {

    msgMarker = getMessageMarker(message, application);
    final String correlationId = message.headers().get(MicrodoseConstants.ONE_DATA_CORRELATION_ID);
    final String channelId =
            Optional.ofNullable(message.headers().get(DemographicsConstants.CHANNEL))
                    .orElse(DemographicsConstants.DEFAULT_CHANNEL).toUpperCase();
    final JsonObject request = message.body();
    JsonArray finalResponse = new JsonArray();

    String userId = configResult.getJsonObject("postgres-config", new JsonObject())
            .getJsonObject("gcharcore", new JsonObject())
            .getJsonObject("primary", new JsonObject())
            .getString("user");
    log.info(msgMarker, "New Request with channel id = {} , SOR , {}, correlation id = {} , request = {}, userId = {}",
            channelId, FUNCTION_NAME, correlationId, request, userId);

    final boolean gms = GMS_CONSUMERS.contains(channelId);

    try {
      final Optional<ErrorResponse> errors = validateRequest(request);
      if (errors.isPresent()) {
        final ErrorResponse errorResponse = errors.get();
        log.error(msgMarker, "Validation failed = {}", errorResponse);
        finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
        sendReply(msgMarker, message, correlationId, channelId, finalResponse, FAILURE, HttpStatus.SC_BAD_REQUEST);
      } else {
        processRequest(msgMarker, request, correlationId, gms).onFailure(cause -> {
          final ErrorResponse response =
                  new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR), cause.getLocalizedMessage());
          sendReply(msgMarker, message, correlationId, channelId, response.toJson(), FAILURE,
                  HttpStatus.SC_INTERNAL_SERVER_ERROR);
        }).onSuccess(response -> {
          if (null == response || response.isEmpty()) {
            log.info(msgMarker, "Response is null or empty from database");
            final ErrorResponse errorResponse = new ErrorResponse(String.valueOf(HttpStatus.SC_NOT_FOUND),
                    "RECORD_NOT_FOUND");
            try {
              finalResponse.add(new JsonObject(objectMapper.writeValueAsString(errorResponse)));
            } catch (JsonProcessingException e) {
              throw new RuntimeException(e);
            }
            sendReply(msgMarker, message, correlationId, channelId, finalResponse, FAILURE, HttpStatus.SC_NOT_FOUND);
          } else {
            sendReply(msgMarker, message, correlationId, channelId, response, SUCCESS, HttpStatus.SC_OK);
          }
        });
      }
    } catch (Exception e) {
      log.info(msgMarker, "EXCEPTION OCCURRED WHILE PROCESSING REQUEST. DETAILS = {}", e.getLocalizedMessage());
      final ErrorResponse response =
              new ErrorResponse(String.valueOf(HttpStatus.SC_INTERNAL_SERVER_ERROR), e.getLocalizedMessage());
      sendReply(msgMarker, message, correlationId, channelId, response.toJson(), FAILURE,
              HttpStatus.SC_INTERNAL_SERVER_ERROR);
    }
  }
