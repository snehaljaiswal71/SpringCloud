import io.vertx.core.*;
import io.vertx.core.json.JsonObject;
import org.junit.Before;
import org.junit.Test;
import org.mockito.*;
import org.slf4j.Marker;

import java.lang.reflect.Field;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class InitializeDBComponentImplTest {

    @InjectMocks
    private InitializeDBComponentImpl initializeDBComponent;

    @Mock
    private Vertx mockVertx;

    @Mock
    private Marker mockMarker;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        initializeDBComponent = new InitializeDBComponentImpl();
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    /**
     * Test for initializeDBComponent with verticle approach enabled.
     */
    @Test
    public void testInitializeDBComponentAsVerticle() throws Exception {
        // Arrange
        JsonObject config = new JsonObject()
                .put("common", new JsonObject()
                        .put("db.jar.verticle.approach.active", true));

        doAnswer(invocation -> {
            Handler<AsyncResult<String>> handler = invocation.getArgument(2);
            handler.handle(Future.succeededFuture("DeploymentID"));
            return null;
        }).when(mockVertx).deployVerticle(any(), any(DeploymentOptions.class), any());

        // Act
        Future<DBComponentDirectInstance> future = initializeDBComponent.initializeDBComponent(mockVertx, config, mockMarker);

        // Assert
        assertNotNull(future);
        assertTrue(future.succeeded());
    }

    /**
     * Test for initializeDBComponent with direct instance approach enabled.
     */
    @Test
    public void testInitializeDBComponentAsDirectInstance() throws Exception {
        // Arrange
        JsonObject config = new JsonObject()
                .put("common", new JsonObject()
                        .put("db.jar.verticle.approach.active", false));

        DBComponentDirectInstance mockDBComponentDirectInstance = mock(DBComponentDirectInstance.class);

        doReturn(Future.succeededFuture(mockDBComponentDirectInstance))
                .when(mockDBComponentDirectInstance).init(any(Vertx.class), any(JsonObject.class), any(Marker.class));

        // Use Reflection to replace the private `initializeAsDirectInstance` method's behavior
        setPrivateField(initializeDBComponent, "vertx", mockVertx);
        setPrivateField(initializeDBComponent, "config", config);

        // Act
        Future<DBComponentDirectInstance> future = initializeDBComponent.initializeDBComponent(mockVertx, config, mockMarker);

        // Assert
        assertNotNull(future);
        assertTrue(future.succeeded());
    }

    /**
     * Test for initializeDBComponent with invalid configuration.
     */
    @Test
    public void testInitializeDBComponentWithInvalidConfig() {
        // Arrange
        JsonObject invalidConfig = new JsonObject(); // No "common" config provided.

        // Act
        Future<DBComponentDirectInstance> future = initializeDBComponent.initializeDBComponent(mockVertx, invalidConfig, mockMarker);

        // Assert
        assertNotNull(future);
        assertTrue(future.failed());
    }
}
