public void performCacheLoad(
      JsonObject cacheConfig, JsonObject config, Promise<Void> startPromise, Marker classMarker) {
    ArrayList<Future> futures = new ArrayList<>();
    String correlationId = "Cache-" + UUID.randomUUID();

     cacheConfig.stream()
        .forEach(
            table -> {
              JsonObject value = JsonObject.mapFrom(table.getValue());
              if (Boolean.TRUE.equals(value.getBoolean("cache_enable", false))) {
                if (value.getString("type").equals("groupBy")) {
                  futures.add(
                      loadCacheGroupBy(
                          table.getKey(),
                          value.getString(KEY),
                          value.getString(DATABASE),
                          config.getString(value.getString(QUERY)),
                          value.getString(GROUP_BY_TABLE),
                          value.getString(GROUP_BY_COLUMN),
                          correlationId,
                          classMarker));
                }

}

private Future<Void> loadCacheGroupBy(
      String mapKey,
      String valueKey,
      String database,
      String sqlQuery,
      String table,
      String column,
      String correlationId,
      Marker classMarker) {
    Promise<Void> loadCache = Promise.promise();

    try {

      Promise<Map<String, Map<String, JsonObject>>> dsPromise = Promise.promise();
      try {
        JsonArray params = new JsonArray();
        transactionalReferenceDataService.executePreparedQueryList(
            sqlQuery,
            params,
            database,
            10000,
            correlationId,
            classMarker,
            asyncResult -> {
              if (asyncResult.succeeded()) {
                JsonArray array = asyncResult.result();
                if (array != null) {
                  Map<String, Map<String, JsonObject>> mapresult =
                      array.stream()
                          .collect(
                              groupingBy(
                                  a -> ((JsonObject) a).getString(table).trim(),
                                  Collectors.toMap(
                                      b -> ((JsonObject) b).getString(column),
                                      a -> ((JsonObject) a))));

                  dsPromise.complete(mapresult);
                } else {
                  LOGGER.error(
                      classMarker,
                      "{} : CorrelationId: {}, loadCacheGroupBy cache result is null for : {} ",
                      DB_JAR_ERROR,
                      correlationId,
                      mapKey);
                  dsPromise.fail("cache result is null for : " + mapKey);
                }
              } else {
                dsPromise.fail(asyncResult.cause());
              }
            });
      } catch (Exception e) {
        LOGGER.error(
            classMarker,
            "{} : CorrelationId : {}, Exception loadCacheGroupBy cache result is null for : {}, Reason: {}, Trace: {}",
            DB_JAR_ERROR,
            correlationId,
            mapKey,
            e.getLocalizedMessage(),
            ExceptionUtils.getStackTrace(e));
        dsPromise.fail(e);
      }

      dsPromise
          .future()
          .onComplete(
              resultAsync -> {
                if (resultAsync.succeeded()) {
                  Map<String, Map<String, JsonObject>> obj = resultAsync.result();
                  JsonObject json = new JsonObject();
                  obj.forEach(
                      (key, value) -> {
                        json.put(key, value);
                      });
                  cache.put(mapKey, mapKey, json);
                  loadCache.complete();
                } else {
                  LOGGER.error(
                      classMarker,
                      "{} : CorrelationId: {}, Issue while Metadata cache loading, Reason: {}, Trace: {}",
                      DB_JAR_ERROR,
                      correlationId,
                      resultAsync.cause() != null
                          ? resultAsync.cause().getLocalizedMessage()
                          : "Cause is null",
                      resultAsync.cause());
                  loadCache.fail(resultAsync.cause());
                }
              });

    } catch (Exception e) {
      LOGGER.error(
          classMarker,
          "{} : CorrelationId: {}, Exception occurred in loadCacheGroupBy method. Reason: {}, Trace: {}",
          DB_JAR_ERROR,
          correlationId,
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
      loadCache.fail(e);
    }
    return loadCache.future();
  }
}
