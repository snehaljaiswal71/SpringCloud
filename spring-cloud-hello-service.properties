import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import com.aexp.gmdl.db.component.service.TransactionalReferenceDataService;
import com.aexp.gmdl.db.component.verticle.DBComponentDirectInstance;
import com.aexp.gmdl.db.component.verticle.LoadCacheMapDataVerticle;
import com.aexp.gmdl.db.component.verticle.DBHealthCheckVerticle;
import io.vertx.core.*;
import io.vertx.core.json.JsonObject;
import org.junit.Before;
import org.junit.Test;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;

import java.util.ArrayList;
import java.util.List;

public class DBComponentDirectInstanceTest {

    @Mock
    private Vertx mockVertx;

    @Mock
    private JsonObject mockConfig;

    @Mock
    private Marker mockClassMarker;

    @Mock
    private TransactionalReferenceDataService mockTransactionalReferenceDataService;

    @Mock
    private LoadCacheMapDataVerticle mockLoadCacheMapDataVerticle;

    @Mock
    private DBHealthCheckVerticle mockDBHealthCheckVerticle;

    @Mock
    private CompositeFuture mockCompositeFuture;

    private DBComponentDirectInstance dbComponentDirectInstance;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);

        // Mock the static create method of TransactionalReferenceDataService
        when(TransactionalReferenceDataService.create(mockVertx, mockConfig, mockClassMarker))
            .thenReturn(mockTransactionalReferenceDataService);

        // Initialize the DBComponentDirectInstance
        dbComponentDirectInstance = new DBComponentDirectInstance();
    }

    @Test
    public void testInit_Success() {
        // Prepare the futures
        Future<Void> loadCacheMapDataFuture = mock(Future.class);
        Future<Void> dbHealthCheckFuture = mock(Future.class);

        List<Future> listCache = new ArrayList<>();
        listCache.add(loadCacheMapDataFuture);
        listCache.add(dbHealthCheckFuture);

        // Mock the behavior of the composite future
        when(CompositeFuture.all(listCache)).thenReturn(mockCompositeFuture);
        when(mockCompositeFuture.onComplete(any())).thenAnswer(invocation -> {
            Handler<AsyncResult<Void>> handler = invocation.getArgument(0);
            handler.handle(Future.succeededFuture());
            return null;
        });

        // Call the init method
        Future<Void> result = dbComponentDirectInstance.init(mockVertx, mockConfig, mockClassMarker);

        // Verify that the success log is executed
        verify(mockCompositeFuture).onComplete(any());
        verify(mockTransactionalReferenceDataService).create(mockVertx, mockConfig, mockClassMarker);
        assertTrue(result.succeeded());
    }

    @Test
    public void testInit_Failure() {
        // Prepare the futures
        Future<Void> loadCacheMapDataFuture = mock(Future.class);
        Future<Void> dbHealthCheckFuture = mock(Future.class);

        List<Future> listCache = new ArrayList<>();
        listCache.add(loadCacheMapDataFuture);
        listCache.add(dbHealthCheckFuture);

        // Mock the behavior of the composite future to simulate failure
        when(CompositeFuture.all(listCache)).thenReturn(mockCompositeFuture);
        when(mockCompositeFuture.onComplete(any())).thenAnswer(invocation -> {
            Handler<AsyncResult<Void>> handler = invocation.getArgument(0);
            handler.handle(Future.failedFuture("Simulated failure"));
            return null;
        });

        // Call the init method
        Future<Void> result = dbComponentDirectInstance.init(mockVertx, mockConfig, mockClassMarker);

        // Verify that the failure log is executed
        verify(mockCompositeFuture).onComplete(any());
        assertTrue(result.failed());
    }
}
