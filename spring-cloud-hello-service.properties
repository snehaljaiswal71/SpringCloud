package com.aexp.gmdl.db.component.verticle;

import static com.aexp.gmdl.db.component.constants.AppConstants.*;
import static java.util.stream.Collectors.groupingBy;

import com.aexp.gmdl.db.component.service.*;
import io.vertx.core.*;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;

public class LoadCacheMapDataVerticle {

  private static final Logger LOGGER = LoggerFactory.getLogger(LoadCacheMapDataVerticle.class);
  private static Boolean isFirst;
  JsonObject config;
  Vertx vertx;
  LocalCache cache;
  TransactionalReferenceDataService transactionalReferenceDataService;

  public static class LocalCache {
    static Map<String, JsonObject> cacheMap =
        new HashMap<>(); //  Map<String, Map<String, MAP<String, JsonObject>>>

    private void put(String cacheKey, String valueKey, JsonObject value) {
      cacheMap.put(valueKey, value);
    }

    public static JsonObject get(
        String cacheKey, String valueKey, String correlationId, Marker marker) {

      if (cacheMap.get(cacheKey) != null) {
        return cacheMap.get(cacheKey).getJsonObject(valueKey);
      } else {
        LOGGER.info(
            marker,
            "{} : CorrelationId: {}, Cache not present for cacheKey: {}, valueKey: {}, Size: {}",
            DB_JAR,
            correlationId,
            cacheKey,
            valueKey,
            cacheMap.size());

        if (cacheMap.size() > 0) {
          for (String key : cacheMap.keySet()) {
            LOGGER.debug(
                "{} : CorrelationId: {}, Cache for cacheKey: {} is {}",
                DB_JAR,
                correlationId,
                key,
                cacheMap.get(key));
          }
        }

        return null;
      }
    }

    public static JsonArray getJsonArray(
        String cacheKey, String valueKey, String correlationId, Marker marker) {
      if (cacheMap.get(cacheKey) != null) {
        JsonArray jsonArray = cacheMap.get(cacheKey).getJsonArray(valueKey);
        return jsonArray;
      } else {
        LOGGER.info(
            marker,
            "{} : CorrelationId: {}, Cache not present for :{}",
            "DB_JAR",
            correlationId,
            cacheKey);
        return null;
      }
    }
  }

  public Future<Void> init(
      Vertx vertx,
      JsonObject config,
      TransactionalReferenceDataService transactionalReferenceDataService,
      Marker classMarker) {
    Promise<Void> startPromise = Promise.promise();
    try {
      isFirst = true;
      cache = new LocalCache();
      this.vertx = vertx;
      this.config = config;
      this.transactionalReferenceDataService = transactionalReferenceDataService;

      JsonObject cacheConfig = config.getJsonObject("cache");

      if (cacheConfig != null) {
        LOGGER.info(classMarker, "DB_JAR : Initializing LocalCache.");
        JsonObject commonConfig = config.getJsonObject("common");

        boolean cacheRefreshEnabled = commonConfig.getBoolean("cache.refresh.enabled", true);

        if (cacheRefreshEnabled) {
          TimerTask timerTask =
              new TimerTask() {
                @Override
                public void run() {
                  performCacheLoad(cacheConfig, config, startPromise, classMarker);
                }
              };

          Timer timer = new Timer();
          Calendar today = Calendar.getInstance();

          timer.schedule(
              timerTask,
              today.getTime(),
              TimeUnit.MILLISECONDS.convert(
                  commonConfig.getInteger("cache.refresh.interval", 30000),
                  TimeUnit.valueOf(
                      commonConfig.getString("cache.refresh.interval.unit", "SECONDS"))));
        } else {
          LOGGER.info(classMarker, "DB_JAR : Cache refresh disabled");
          performCacheLoad(cacheConfig, config, startPromise, classMarker);
        }
      } else {
        LOGGER.warn(classMarker, "{} : No Cache is not enabled", DB_JAR);
        startPromise.complete();
      }
    } catch (Exception e) {
      LOGGER.error(
          classMarker,
          "{} : Exception in LoadCacheMapData Verticle : Reason: {}, Trace: {}",
          DB_JAR_ERROR,
          e.getLocalizedMessage(),
          ExceptionUtils.getStackTrace(e));
      startPromise.fail(e);
    }

    return startPromise.future();
  }
