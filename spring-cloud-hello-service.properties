@RunWith(VertxUnitRunner.class)
public class ReadUnifiedMerchantDemographicsNewVerticleTest {

    private Vertx vertx;
    private ReadUnifiedMerchantDemographicsNewVerticle verticle;

    @Before
    public void setUp(TestContext context) {
        vertx = Vertx.vertx();
        verticle = new ReadUnifiedMerchantDemographicsNewVerticle();
    }

    @After
    public void tearDown() {
        vertx.close();
    }

    @Test
    public void testStart_successfulStartup(TestContext context) {
        JsonObject mockConfig = new JsonObject()
            .put("lambdaConfig", new JsonObject()
                .put("decryption", new JsonObject()))
            .put("postgres-config", new JsonObject()
                .put("gcharcore", new JsonObject()
                    .put("primary", new JsonObject()
                        .put("user", "mockUser"))));

        Promise<Void> startPromise = Promise.promise();

        try (
            MockedStatic<InitializeDBComponent> initDbMock = Mockito.mockStatic(InitializeDBComponent.class);
            MockedStatic<TransactionalReferenceDataService> dataServiceMock = Mockito.mockStatic(TransactionalReferenceDataService.class);
        ) {
            // Mock the DB initializer static method
            initDbMock.when(() -> InitializeDBComponent.initializeDBComponent(
                any(), any(), any()))
                .thenReturn(Future.succeededFuture());

            // Mock the data service static create method
            TransactionalReferenceDataService mockService = mock(TransactionalReferenceDataService.class);
            dataServiceMock.when(() -> TransactionalReferenceDataService.create(
                any(), any(), any(), any()))
                .thenReturn(mockService);

            vertx.deployVerticle(verticle, context.asyncAssertSuccess());
        }
    }

    @Test
    public void testHandle_validRequest_shouldReturnSuccess(TestContext context) throws Exception {
        JsonObject request = new JsonObject().put("valid", true);
        JsonObject configResult = new JsonObject()
            .put("postgres-config", new JsonObject()
                .put("gcharcore", new JsonObject()
                    .put("primary", new JsonObject()
                        .put("user", "mockUser"))));

        Message<JsonObject> mockMessage = mock(Message.class);
        when(mockMessage.body()).thenReturn(request);

        MultiMap headers = new CaseInsensitiveHeaders();
        headers.add("correlation-id", "corr-id");
        headers.add("channel", "CHANNEL-A");
        when(mockMessage.headers()).thenReturn(headers);

        ReadUnifiedMerchantDemographicsNewVerticle vert = new ReadUnifiedMerchantDemographicsNewVerticle();
        vert.configResult = configResult;

        // Mock processRequest
        ReadUnifiedMerchantDemographicsNewVerticle spyVert = Mockito.spy(vert);
        doReturn(Future.succeededFuture(new JsonArray().add(new JsonObject().put("status", "ok"))))
                .when(spyVert).processRequest(any(), any(), any(), anyBoolean());

        spyVert.handle(mockMessage);

        // Optionally verify sendReply was called
        verify(mockMessage, atLeastOnce()).body(); // Add more verifications as needed
    }
}
