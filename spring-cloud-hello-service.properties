import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.slf4j.Marker;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(VertxExtension.class)
public class DBComponentVerticleTest {

    private Vertx vertx;
    private DBComponentVerticle verticle;
    private JsonObject config;
    private Marker classMarker;

    @BeforeEach
    public void setUp() {
        vertx = Vertx.vertx();
        verticle = new DBComponentVerticle();
        config = new JsonObject();
        classMarker = mock(Marker.class);

        // Set up the config for the verticle
        config.put("classMarker", new JsonObject());
        verticle.init(vertx, vertx.getOrCreateContext(), config);
    }

    @Test
    public void testStart_Success(VertxTestContext testContext) {
        // Arrange
        LoadCacheMapDataVerticle loadCacheMapDataVerticle = mock(LoadCacheMapDataVerticle.class);
        DBHealthCheckVerticle dbHealthCheckVerticle = mock(DBHealthCheckVerticle.class);

        Future<Void> future1 = Future.succeededFuture();
        Future<Void> future2 = Future.succeededFuture();

        // Mock verticles initialization
        when(loadCacheMapDataVerticle.init(eq(vertx), eq(config), any(), eq(classMarker)))
                .thenReturn(future1);
        when(dbHealthCheckVerticle.init(eq(vertx), eq(config), any(), eq(classMarker)))
                .thenReturn(future2);

        verticle.setLoadCacheMapDataVerticle(loadCacheMapDataVerticle);
        verticle.setDbHealthCheckVerticle(dbHealthCheckVerticle);

        // Act
        Promise<Void> startPromise = Promise.promise();
        verticle.start(startPromise);

        // Assert
        startPromise.future().onComplete(ar -> {
            if (ar.succeeded()) {
                testContext.verify(() -> {
                    assertTrue(ar.succeeded(), "Start should succeed");
                    testContext.completeNow();
                });
            } else {
                testContext.failNow(ar.cause());
            }
        });
    }

    @Test
    public void testStart_Failure(VertxTestContext testContext) {
        // Arrange
        LoadCacheMapDataVerticle loadCacheMapDataVerticle = mock(LoadCacheMapDataVerticle.class);
        DBHealthCheckVerticle dbHealthCheckVerticle = mock(DBHealthCheckVerticle.class);

        Future<Void> future1 = Future.failedFuture("Future 1 failed");
        Future<Void> future2 = Future.succeededFuture();

        // Mock verticles initialization
        when(loadCacheMapDataVerticle.init(eq(vertx), eq(config), any(), eq(classMarker)))
                .thenReturn(future1);
        when(dbHealthCheckVerticle.init(eq(vertx), eq(config), any(), eq(classMarker)))
                .thenReturn(future2);

        verticle.setLoadCacheMapDataVerticle(loadCacheMapDataVerticle);
        verticle.setDbHealthCheckVerticle(dbHealthCheckVerticle);

        // Act
        Promise<Void> startPromise = Promise.promise();
        verticle.start(startPromise);

        // Assert
        startPromise.future().onComplete(ar -> {
            testContext.verify(() -> {
                assertTrue(ar.failed(), "Start should fail");
                assertEquals("Future 1 failed", ar.cause().getMessage(), "Failure cause should match");
                testContext.completeNow();
            });
        });
    }

    @Test
    public void testStop_Success(VertxTestContext testContext) {
        // Arrange
        Promise<Void> stopPromise = Promise.promise();

        // Act
        verticle.stop(stopPromise);

        // Assert
        stopPromise.future().onComplete(ar -> {
            testContext.verify(() -> {
                assertTrue(ar.succeeded(), "Stop should succeed");
                testContext.completeNow();
            });
        });
    }

    @Test
    public void testStop_NullMarker(VertxTestContext testContext) {
        // Arrange
        Promise<Void> stopPromise = Promise.promise();

        // Set null marker in the configuration
        config.remove("classMarker");

        // Act
        verticle.stop(stopPromise);

        // Assert
        stopPromise.future().onComplete(ar -> {
            testContext.verify(() -> {
                assertTrue(ar.succeeded(), "Stop should succeed even if marker is null");
                testContext.completeNow();
            });
        });
    }
}
