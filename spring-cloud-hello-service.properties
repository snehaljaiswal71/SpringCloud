@Test
public void testInitAndHandle_SuccessfulQuery() {
    // Prepare request body and headers for the mock message
    JsonObject requestBody = new JsonObject()
            .put("sqlQuery", "SELECT 1")
            .put("dbConfig", new JsonObject().put("url", "jdbc:test"));

    MultiMap headers = MultiMap.caseInsensitiveMultiMap();
    when(mockMessage.body()).thenReturn(requestBody);
    when(mockMessage.headers()).thenReturn(headers);

    // Mock other dependencies
    MessageMarker mockMessageMarker = mock(MessageMarker.class);
    when(MessageMarker.getMessageMarker(headers)).thenReturn(mockMessageMarker);

    when(JDBCClient.createShared(mockVertx, requestBody.getJsonObject("dbConfig"))).thenReturn(mockJdbcClient);

    doAnswer(invocation -> {
        Handler<AsyncResult<SQLConnection>> handler = invocation.getArgument(0);
        handler.handle(Future.succeededFuture(mockSqlConnection));
        return null;
    }).when(mockJdbcClient).getConnection(any());

    doAnswer(invocation -> {
        Handler<AsyncResult<Void>> closeHandler = invocation.getArgument(0);
        closeHandler.handle(Future.succeededFuture());
        return null;
    }).when(mockSqlConnection).close(any());

    doAnswer(invocation -> {
        Handler<AsyncResult<io.vertx.ext.sql.ResultSet>> queryHandler = invocation.getArgument(1);
        queryHandler.handle(Future.succeededFuture());
        return null;
    }).when(mockSqlConnection).query(eq("SELECT 1"), any());

    // Call init, which internally calls handle
    Future<Void> initFuture = verticle.init(mockVertx, mockConfig, mockService, mockMarker);

    // Verify that handle processes the message correctly
    verify(mockMessage).reply(argThat(response -> {
        JsonObject jsonResponse = (JsonObject) response;
        return "Success".equals(jsonResponse.getString("connection-status")) &&
               "Success".equals(jsonResponse.getString("query-run-status"));
    }));
}
