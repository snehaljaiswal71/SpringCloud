package com.axp.microdose.unified.merchant.read.demographics.sor;

import com.aexp.gmdl.db.component.service.TransactionalReferenceDataService;
import com.aexp.gmdl.db.component.verticle.InitializeDBComponentImpl;
import com.axp.test.BaseTest;
import io.vertx.core.*;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.ResultSet;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;
import org.assertj.core.api.WithAssertions;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.stubbing.Answer;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import org.powermock.modules.junit4.PowerMockRunnerDelegate;
import org.slf4j.Marker;


import java.io.IOException;
import java.util.List;

import static com.axp.microdose.commons.MicrodoseConstants.ONE_DATA_CORRELATION_ID;
import static com.axp.microdose.unified.merchant.read.demographics.util.DemographicsConstants.*;

@RunWith(PowerMockRunner.class)
@PowerMockRunnerDelegate(VertxUnitRunner.class)
@PrepareForTest({JDBCClient.class, ReadUnifiedMerchantDemographicsVerticle.class,
    TransactionalReferenceDataService.class})
public class ReadUnifiedMerchantDemographicsVerticleTest extends BaseTest implements WithAssertions {

  @Mock
  private JDBCClient primary;
  private JsonObject request;
  public static final String CONFIG_PATH = "config";
  @Mock
  private TransactionalReferenceDataService transactionalReferenceDataService;
  public static final String TEST_IDENTIFIER = "5361141864";
  public static final String SOR_FUNCTION = "ReadUnifiedMerchantDemographics.sor.v1";
  InitializeDBComponentImpl dbv;
  @InjectMocks
  ReadUnifiedMerchantDemographicsVerticle verticle = new ReadUnifiedMerchantDemographicsVerticle();

  @Before
  public void setUp(TestContext context) throws Exception {
    dbv = PowerMockito.mock(InitializeDBComponentImpl.class);
    PowerMockito.whenNew(InitializeDBComponentImpl.class)
            .withNoArguments()
            .thenReturn(dbv);

    Mockito.when(dbv.initializeDBComponent(Mockito.any(), Mockito.any(), Mockito.any()))
            .thenReturn(Future.succeededFuture());

    PowerMockito.mockStatic(TransactionalReferenceDataService.class);
    PowerMockito.when(TransactionalReferenceDataService.create(Mockito.any(), Mockito.any(),
                    Mockito.any(), Mockito.any()))
            .thenReturn(transactionalReferenceDataService);
    final JsonObject testConfig = new JsonObject(readFile(CONFIG_PATH + "test_config.json"));
    DeploymentOptions deploymentOptions = new DeploymentOptions().setConfig(testConfig);
    vertx.deployVerticle(verticle, deploymentOptions, context.asyncAssertSuccess());
  }

  @Test
  public void shouldSucceedToHandleRequestWithOptionalFields(TestContext context) throws IOException {
    request = new JsonObject().put(CORE_ATTRIBUTES,
            new JsonObject().put(MERCHANT_IDENTIFIER_LIST, new JsonArray().add(TEST_IDENTIFIER))
                    .put(ACQUIRING_INSTITUTION_IDENTIFICATION_NUMBER, "10000000192")
                    .put(SOURCE_SYSTEM_IDENTIFIER, "USD")
                    .put(BUSINESS_CENTER_CODE, "002"));
    final JsonArray expected = new JsonArray(readFile(CONFIG_PATH + "response.json"));
    final String seNumber = "5361141864";
    final String ainNumber = "10000000192";
    final String setId = "Sample";
    final String sourceSystemId = "USD";
    final String busCenterCode = "002";

    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(ONE_DATA_CORRELATION_ID, "shouldSucceedToHandleRequest");
    final JsonArray mockResponse = new JsonArray();
    JsonObject jsonObject = new JsonObject();
    jsonObject.put(MERCHANT_IDENTIFIER, TEST_IDENTIFIER);
    jsonObject.put(ACQUIRING_INSTITUTION_IDENTIFICATION_NUMBER, TEST_IDENTIFIER);
    mockResponse.add(jsonObject);

    final JsonArray finalResponse = new JsonArray();
    JsonObject result = new JsonObject()
            .put("mer_id", seNumber)
            .put("ain_no", ainNumber)
            .put("set_id", setId)
            .put("srce_sys_id", sourceSystemId)
            .put("bus_ctr_cd", busCenterCode);
    finalResponse.add(result);

    AsyncResult<JsonArray> reply1 = Mockito.mock(AsyncResult.class);
    Mockito.doAnswer(
                    (Answer<AsyncResult<JsonArray>>)
                            invocation -> {
                              invocation
                                      .<Handler<AsyncResult<JsonArray>>>getArgument(6)
                                      .handle(reply1);
                              return null;
                            })
            .when(transactionalReferenceDataService)
            .executePreparedQueryList(
                    Mockito.anyString(),
                    Mockito.any(JsonArray.class),
                    Mockito.anyString(),
                    Mockito.anyInt(),
                    Mockito.anyString(), Mockito.any(Marker.class),
                    Mockito.any(Handler.class));

    Mockito.when(reply1.succeeded()).thenReturn(true);
    JsonArray response = new JsonArray();
    response.add(result);
    Mockito.when(reply1.result()).thenReturn(response);

    ResultSet resultSet = Mockito.mock(ResultSet.class);
    Mockito.when(resultSet.getRows()).thenReturn(List.of(result));

    @SuppressWarnings("unchecked")
    AsyncResult<ResultSet> resultSetAsyncResult = Mockito.mock(AsyncResult.class);
    Mockito.when(resultSetAsyncResult.succeeded()).thenReturn(true);
    Mockito.when(resultSetAsyncResult.result()).thenReturn(resultSet);

    PowerMockito.mockStatic(JDBCClient.class);
    PowerMockito
            .when(JDBCClient.create(Mockito.any(Vertx.class), Mockito.any(JsonObject.class)))
            .thenReturn(primary);

    final SQLConnection sqlConnection = Mockito.mock(SQLConnection.class);
    @SuppressWarnings("unchecked")
    AsyncResult<SQLConnection> sqlConnectionAsyncResult = Mockito.mock(AsyncResult.class);
    Mockito.when(sqlConnectionAsyncResult.succeeded()).thenReturn(true);
    Mockito.when(sqlConnectionAsyncResult.result()).thenReturn(sqlConnection);
    Mockito.doAnswer((Answer<AsyncResult<SQLConnection>>) arg0 -> {
      Handler<AsyncResult<SQLConnection>> handler = arg0.getArgument(0);
      handler.handle(sqlConnectionAsyncResult);
      return null;
    }).when(primary).getConnection(Mockito.any());

    Mockito.doAnswer((Answer<AsyncResult<ResultSet>>) arg0 -> {
      final Handler<AsyncResult<ResultSet>> handler = arg0.getArgument(2);
      handler.handle(resultSetAsyncResult);
      return null;
    }).when(sqlConnection).queryWithParams(Mockito.any(), Mockito.any(JsonArray.class), Mockito.any());

    vertx.eventBus().request(SOR_FUNCTION, request, options, context.asyncAssertSuccess(reply ->
            context.verify(v -> {

              final String actualReply = reply.body().toString();
              assertThat(actualReply).isEqualTo(expected.toString());
            })));

  }

  @Test
  public void shouldSucceedToHandleRequest(TestContext context) throws IOException {
    request = new JsonObject().put(CORE_ATTRIBUTES,
            new JsonObject().put(MERCHANT_IDENTIFIER_LIST, new JsonArray().add(TEST_IDENTIFIER)));
    final JsonArray expected = new JsonArray(readFile(CONFIG_PATH + "response.json"));
    final String seNumber = "5361141864";
    final String ainNumber = "10000000192";
    final String setId = "Sample";
    final String sourceSystemId = "USD";
    final String busCenterCode = "002";

    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(ONE_DATA_CORRELATION_ID, "shouldSucceedToHandleRequest");

    JsonObject resultWithExcessSpaces = new JsonObject()
            .put("mer_id", seNumber)
            .put("ain_no", ainNumber)
            .put("set_id", setId)
            .put("srce_sys_id", sourceSystemId)
            .put("bus_ctr_cd", busCenterCode);

    AsyncResult<JsonArray> reply1 = Mockito.mock(AsyncResult.class);
    Mockito.doAnswer(
                    (Answer<AsyncResult<JsonArray>>)
                            invocation -> {
                              invocation
                                      .<Handler<AsyncResult<JsonArray>>>getArgument(6)
                                      .handle(reply1);
                              return null;
                            })
            .when(transactionalReferenceDataService)
            .executePreparedQueryList(
                    Mockito.anyString(),
                    Mockito.any(JsonArray.class),
                    Mockito.anyString(),
                    Mockito.anyInt(),
                    Mockito.anyString(), Mockito.any(),
                    Mockito.any(Handler.class));

    Mockito.when(reply1.succeeded()).thenReturn(true);
    JsonArray response = new JsonArray();
    response.add(resultWithExcessSpaces);
    Mockito.when(reply1.result()).thenReturn(response);

    ResultSet resultSet = Mockito.mock(ResultSet.class);
    Mockito.when(resultSet.getRows()).thenReturn(List.of(resultWithExcessSpaces));

    @SuppressWarnings("unchecked")
    AsyncResult<ResultSet> resultSetAsyncResult = Mockito.mock(AsyncResult.class);
    Mockito.when(resultSetAsyncResult.succeeded()).thenReturn(true);
    Mockito.when(resultSetAsyncResult.result()).thenReturn(resultSet);

    PowerMockito.mockStatic(JDBCClient.class);
    PowerMockito
            .when(JDBCClient.create(Mockito.any(Vertx.class), Mockito.any(JsonObject.class)))
            .thenReturn(primary);

    final SQLConnection sqlConnection = Mockito.mock(SQLConnection.class);
    @SuppressWarnings("unchecked")
    AsyncResult<SQLConnection> sqlConnectionAsyncResult = Mockito.mock(AsyncResult.class);
    Mockito.when(sqlConnectionAsyncResult.succeeded()).thenReturn(true);
    Mockito.when(sqlConnectionAsyncResult.result()).thenReturn(sqlConnection);
    Mockito.doAnswer((Answer<AsyncResult<SQLConnection>>) arg0 -> {
      Handler<AsyncResult<SQLConnection>> handler = arg0.getArgument(0);
      handler.handle(sqlConnectionAsyncResult);
      return null;
    }).when(primary).getConnection(Mockito.any());

    Mockito.doAnswer((Answer<AsyncResult<ResultSet>>) arg0 -> {
      final Handler<AsyncResult<ResultSet>> handler = arg0.getArgument(2);
      handler.handle(resultSetAsyncResult);
      return null;
    }).when(sqlConnection).queryWithParams(Mockito.any(), Mockito.any(JsonArray.class), Mockito.any());

    vertx.eventBus().request(SOR_FUNCTION, request, options, context.asyncAssertSuccess(reply ->
            context.verify(v -> {
              final String actualReply = reply.body().toString();
              assertThat(actualReply).isEqualTo(expected.toString());
            })));

  }

  @Test
  public void failWithRequiredAttributeError(TestContext context) {

    request = new JsonObject().put(CORE_ATTRIBUTES,
            new JsonObject().put(MERCHANT_IDENTIFIER_LIST, new JsonArray()));
    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(ONE_DATA_CORRELATION_ID, "failWithRequiredAttributeError");
    final String error = "merchantIdentifierList should contains valid values";
    final JsonArray jsonArray = new JsonArray();
    final JsonObject response = new JsonObject()
            .put("errorCode", "REQUIRED ATTRIBUTE")
            .put("errorMessage", error);
    jsonArray.add(response);

    AsyncResult<JsonArray> reply1 = Mockito.mock(AsyncResult.class);
    Mockito.doAnswer(
                    (Answer<AsyncResult<JsonArray>>)
                            invocation -> {
                              invocation
                                      .<Handler<AsyncResult<JsonArray>>>getArgument(5)
                                      .handle(reply1);
                              return null;
                            })
            .when(transactionalReferenceDataService)
            .executePreparedQueryList(
                    Mockito.anyString(),
                    Mockito.any(JsonArray.class),
                    Mockito.anyString(),
                    Mockito.anyInt(),
                    Mockito.anyString(), Mockito.any(),
                    Mockito.any(Handler.class));

    Mockito.when(reply1.succeeded()).thenReturn(false);
    Mockito.when(reply1.result()).thenReturn(jsonArray);

    vertx.eventBus().request(SOR_FUNCTION, request, options, context.asyncAssertSuccess(reply ->
            context.verify(v -> {
              final String actualReply = reply.body().toString();
              assertThat(actualReply).isEqualTo(jsonArray.toString());
            })));

  }

  @Test
  public void failWhenEmptyRequestSent(TestContext context) throws IOException {
    final JsonObject testConfig = new JsonObject(readFile(CONFIG_PATH + "test_config.json"));
    DeploymentOptions deploymentOptions = new DeploymentOptions().setConfig(testConfig);
    ReadUnifiedMerchantDemographicsVerticle verticle = new ReadUnifiedMerchantDemographicsVerticle();
    vertx.deployVerticle(verticle, deploymentOptions, context.asyncAssertSuccess());

    request = new JsonObject();
    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(ONE_DATA_CORRELATION_ID, "failWhenEmptyRequestSent");
    final String error = "Empty Request. merchantIdentifierList is required";
    final JsonArray jsonArray = new JsonArray();
    final JsonObject response = new JsonObject()
            .put("errorCode", "REQUIRED ATTRIBUTE")
            .put("errorMessage", error);
    jsonArray.add(response);

    AsyncResult<JsonArray> reply1 = Mockito.mock(AsyncResult.class);
    Mockito.doAnswer(
                    (Answer<AsyncResult<JsonArray>>)
                            invocation -> {
                              invocation
                                      .<Handler<AsyncResult<JsonArray>>>getArgument(5)
                                      .handle(reply1);
                              return null;
                            })
            .when(transactionalReferenceDataService)
            .executePreparedQueryList(
                    Mockito.anyString(),
                    Mockito.any(JsonArray.class),
                    Mockito.anyString(),
                    Mockito.anyInt(),
                    Mockito.anyString(), Mockito.any(),
                    Mockito.any(Handler.class));

    Mockito.when(reply1.succeeded()).thenReturn(false);
    Mockito.when(reply1.result()).thenReturn(jsonArray);

    vertx.eventBus().request(SOR_FUNCTION, request, options, context.asyncAssertSuccess(reply ->
            context.verify(v -> {
              final String actualReply = reply.body().toString();
              assertThat(actualReply).isEqualTo(jsonArray.toString());
            })));
  }

  @Test
  public void recordNotFound(TestContext context) throws Exception {
    request = new JsonObject().put(CORE_ATTRIBUTES,
            new JsonObject().put(MERCHANT_IDENTIFIER_LIST, new JsonArray().add(TEST_IDENTIFIER)));
    final JsonArray expected = new JsonArray(readFile(CONFIG_PATH + "noRecordsResponse.json"));
    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(ONE_DATA_CORRELATION_ID, "recordNotFound");

    AsyncResult<JsonArray> reply1 = Mockito.mock(AsyncResult.class);
    Mockito.doAnswer(
                    (Answer<AsyncResult<JsonArray>>)
                            invocation -> {
                              invocation
                                      .<Handler<AsyncResult<JsonArray>>>getArgument(6)
                                      .handle(reply1);
                              return null;
                            })
            .when(transactionalReferenceDataService)
            .executePreparedQueryList(
                    Mockito.anyString(),
                    Mockito.any(JsonArray.class),
                    Mockito.anyString(),
                    Mockito.anyInt(),
                    Mockito.anyString(), Mockito.any(),
                    Mockito.any(Handler.class));

    Mockito.when(reply1.succeeded()).thenReturn(true);
    Mockito.when(reply1.result()).thenReturn(new JsonArray());

    ResultSet resultSet = Mockito.mock(ResultSet.class);
    Mockito.when(resultSet.getRows()).thenReturn(List.of(new JsonObject()));

    @SuppressWarnings("unchecked")
    AsyncResult<ResultSet> resultSetAsyncResult = Mockito.mock(AsyncResult.class);
    Mockito.when(resultSetAsyncResult.succeeded()).thenReturn(true);
    Mockito.when(resultSetAsyncResult.result()).thenReturn(resultSet);

    PowerMockito.mockStatic(JDBCClient.class);
    PowerMockito
            .when(JDBCClient.create(Mockito.any(Vertx.class), Mockito.any(JsonObject.class)))
            .thenReturn(primary);

    final SQLConnection sqlConnection = Mockito.mock(SQLConnection.class);
    @SuppressWarnings("unchecked")
    AsyncResult<SQLConnection> sqlConnectionAsyncResult = Mockito.mock(AsyncResult.class);
    Mockito.when(sqlConnectionAsyncResult.succeeded()).thenReturn(true);
    Mockito.when(sqlConnectionAsyncResult.result()).thenReturn(sqlConnection);
    Mockito.doAnswer((Answer<AsyncResult<SQLConnection>>) arg0 -> {
      Handler<AsyncResult<SQLConnection>> handler = arg0.getArgument(0);
      handler.handle(sqlConnectionAsyncResult);
      return null;
    }).when(primary).getConnection(Mockito.any());

    Mockito.doAnswer((Answer<AsyncResult<ResultSet>>) arg0 -> {
      final Handler<AsyncResult<ResultSet>> handler = arg0.getArgument(2);
      handler.handle(resultSetAsyncResult);
      return null;
    }).when(sqlConnection).queryWithParams(Mockito.any(), Mockito.any(JsonArray.class), Mockito.any());

    vertx.eventBus().request(SOR_FUNCTION, request, options, context.asyncAssertSuccess(reply ->
            context.verify(v -> {
              final String actualReply = reply.body().toString();
              assertThat(actualReply).isEqualTo(expected.toString());
            })));
  }

  @Test
  public void internalServerError(TestContext context) throws IOException {
    request = new JsonObject().put(CORE_ATTRIBUTES,
            new JsonObject().put(MERCHANT_IDENTIFIER_LIST, new JsonArray().add(TEST_IDENTIFIER)));
    final JsonArray expected = new JsonArray(readFile(CONFIG_PATH + "errorResponse.json"));
    JsonArray finalResponse = new JsonArray();
    JsonObject result = new JsonObject();
    finalResponse.add(result);

    Mockito.doAnswer(invocation -> {
      Handler<AsyncResult<JsonArray>> handler = invocation.getArgument(6);
      handler.handle(Future.failedFuture("Db jar failed to process request"));
      return null;
    })
            .when(transactionalReferenceDataService)
            .executePreparedQueryList(
                    Mockito.anyString(),
                    Mockito.any(JsonArray.class),
                    Mockito.anyString(),
                    Mockito.anyInt(),
                    Mockito.anyString(), Mockito.any(),
                    Mockito.any(Handler.class));

    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(ONE_DATA_CORRELATION_ID, "shouldFailToHandleRequest");

    vertx.eventBus().request(SOR_FUNCTION, request, options, context.asyncAssertSuccess(reply ->
            context.verify(v ->
                    assertThat(reply.body()).isEqualTo(expected))));
  }

  @Test
  public void failWhenNullRequest(TestContext context) throws IOException {

    request = null;
    final JsonArray expected = new JsonArray(readFile(CONFIG_PATH + "errorFieldResponse.json"));
    final DeliveryOptions options = new DeliveryOptions()
            .addHeader(ONE_DATA_CORRELATION_ID, "failWhenNullRequest");
    final String error = "coreAttributes is required";
    final JsonArray jsonArray = new JsonArray();
    final JsonObject response = new JsonObject()
            .put("errorCode", "REQUIRED ATTRIBUTE")
            .put("errorMessage", error);
    jsonArray.add(response);

    AsyncResult<JsonArray> reply1 = Mockito.mock(AsyncResult.class);
    Mockito.doAnswer(
                    (Answer<AsyncResult<JsonArray>>)
                            invocation -> {
                              invocation
                                      .<Handler<AsyncResult<JsonArray>>>getArgument(4)
                                      .handle(reply1);
                              return null;
                            })
            .when(transactionalReferenceDataService)
            .executePreparedQueryList(
                    Mockito.anyString(),
                    Mockito.any(JsonArray.class),
                    Mockito.anyString(),
                    Mockito.anyInt(),
                    Mockito.anyString(), Mockito.any(),
                    Mockito.any(Handler.class));

    Mockito.when(reply1.succeeded()).thenReturn(false);
    Mockito.when(reply1.result()).thenReturn(jsonArray);

    vertx.eventBus().request(SOR_FUNCTION, request, options, context.asyncAssertSuccess(reply ->
            context.verify(v -> {
              final String actualReply = reply.body().toString();
              assertThat(actualReply).isEqualTo(expected.toString());
            })));
  }

}
