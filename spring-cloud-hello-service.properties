public final class ValidatorDirectInstance {
    private static final Logger LOGGER = LoggerFactory.getLogger(ValidatorDirectInstance.class);
    private ValidationHandler validationHandler;
    private ReferenceDataService pgReferenceDataService;
    Vertx vertx;
    JsonObject config;

    public ValidatorDirectInstance() {
    }

    private void initializeCryptoUtil(JsonObject FuncConfig) {
        String env = null;
        JsonObject cryptionConfig = null;
        if (this.config.containsKey("lambda-config.json")) {
            env = FuncConfig.getJsonObject("lambda-config.json").getJsonObject("system_property").getString("env");
            cryptionConfig = FuncConfig.getJsonObject("lambda-config.json").getJsonObject("encryptionConfig");
        } else {
            env = System.getenv("EPAAS_ENV");
            cryptionConfig = FuncConfig.getJsonObject("encryptionConfig");
        }

        if (cryptionConfig != null) {
            CryptoUtil.getInstaceOfCryptoUtil(cryptionConfig, env);
        } else {
            LOGGER.warn("VD_JAR : Encryption config not present object not initialized");
        }

    }

    public Future<Void> init(Vertx vertx, JsonObject config, TransactionalReferenceDataService transactionalReferenceDataService, Marker classMarker) {
        Promise<Void> startPromise = Promise.promise();

        try {
            this.vertx = vertx;
            this.config = config;
            this.pgReferenceDataService = ReferenceDataService.create(this.vertx, this.config, classMarker);
            this.validationHandler = new ValidationHandler(this.vertx, this.config, this.pgReferenceDataService, transactionalReferenceDataService);
            this.initializeCryptoUtil(config);
            LOGGER.info("VD_JAR : Deployed Validator Jar successfully");
            startPromise.complete();
        } catch (Exception var7) {
            LOGGER.error("VD_JAR : Failed to deploy Validator Jar");
            startPromise.fail("Failed to deploy Validator Jar");
        }

        return startPromise.future();
    }

    public Future<JsonObject> processData(JsonObject validationPayLoad, Marker marker) {
        Promise<JsonObject> promise = Promise.promise();
        if (validationPayLoad != null) {
            ValidationRequest vReq = new ValidationRequest(validationPayLoad);
            this.handleMessage(vReq, marker).onSuccess((handlerFinalResponse) -> {
                promise.complete(handlerFinalResponse);
            }).onFailure((error) -> {
                JsonArray errorRows = new JsonArray();
                vReq.getRows().stream().forEach((eachRow) -> {
                    JsonObject row = JsonObject.mapFrom(eachRow);
                    JsonArray errors = row.getJsonObject("errors") == null ? new JsonArray() : row.getJsonArray("errors");
                    errors.add((new JsonObject()).put("error_code", "400").put("error_msg", "Validation Jar Failure").put("error_details", error.getLocalizedMessage()));
                    row.put("errors", errors);
                    errorRows.add(row);
                });
                promise.complete((new JsonObject()).put("status", Status.FAILED.name()).put("channel_id", vReq.getChannelId()).put("table_nm", vReq.getTblName()).put("event", vReq.getEvent()).put("rows", errorRows).put("correlation_id", vReq.getBatchCorrelationId()).put("reason", error.getLocalizedMessage()));
            });
        } else {
            LOGGER.error("{} : No response from bulk validation process, validationPayLoadMsg is NUll", "BULK_VALIDATION_ERROR");
            promise.complete((new JsonObject()).put("status", Status.FAILED.name()).put("reason", "Error : Obtained null while bulk validation : " + validationPayLoad));
        }

        return promise.future();
    }

    private Future<JsonObject> handleMessage(ValidationRequest vReq, Marker marker) {
        return this.validationHandler.handle(vReq, marker);
    }
}
