import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import com.aexp.gmdl.db.component.service.TransactionalReferenceDataService;
import com.aexp.gmdl.db.component.util.MessageMarker;
import io.vertx.core.*;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.eventbus.MultiMap;
import org.junit.Before;
import org.junit.Test;
import org.mockito.*;
import org.slf4j.Marker;

public class DBHealthCheckVerticleTest {

    private DBHealthCheckVerticle verticle;
    private Vertx mockVertx;
    private JsonObject mockConfig;
    private TransactionalReferenceDataService mockService;
    private Marker mockMarker;
    private JDBCClient mockJdbcClient;
    private SQLConnection mockSqlConnection;
    private Message<JsonObject> mockMessage;

    @Before
    public void setUp() {
        verticle = new DBHealthCheckVerticle();
        mockVertx = mock(Vertx.class);
        mockConfig = mock(JsonObject.class);
        mockService = mock(TransactionalReferenceDataService.class);
        mockMarker = mock(Marker.class);
        mockJdbcClient = mock(JDBCClient.class);
        mockSqlConnection = mock(SQLConnection.class);
        mockMessage = mock(Message.class);
    }

    @Test
    public void testInit_HealthCheckEnabled() {
        JsonObject commonConfig = new JsonObject().put("healthCheckEnabled", true);
        when(mockConfig.getJsonObject("common")).thenReturn(commonConfig);
        when(mockConfig.getBoolean("healthCheckEnabled", false)).thenReturn(true);

        Promise<Void> promise = Promise.promise();

        Future<Void> result = verticle.init(mockVertx, mockConfig, mockService, mockMarker);
        assertNotNull(result);
    }

    @Test
    public void testInit_HealthCheckDisabled() {
        JsonObject commonConfig = new JsonObject().put("healthCheckEnabled", false);
        when(mockConfig.getJsonObject("common")).thenReturn(commonConfig);
        when(mockConfig.getBoolean("healthCheckEnabled", false)).thenReturn(false);

        Future<Void> result = verticle.init(mockVertx, mockConfig, mockService, mockMarker);

        assertNotNull(result);
    }

    @Test
    public void testHandle_SuccessfulQuery() {
        JsonObject requestBody = new JsonObject()
                .put("sqlQuery", "SELECT 1")
                .put("dbConfig", new JsonObject().put("url", "jdbc:test"));

        MultiMap headers = MultiMap.caseInsensitiveMultiMap();
        when(mockMessage.body()).thenReturn(requestBody);
        when(mockMessage.headers()).thenReturn(headers);

        MessageMarker mockMessageMarker = mock(MessageMarker.class);
        when(MessageMarker.getMessageMarker(headers)).thenReturn(mockMessageMarker);

        when(JDBCClient.createShared(mockVertx, requestBody.getJsonObject("dbConfig"))).thenReturn(mockJdbcClient);

        doAnswer(invocation -> {
            Handler<AsyncResult<SQLConnection>> handler = invocation.getArgument(0);
            handler.handle(Future.succeededFuture(mockSqlConnection));
            return null;
        }).when(mockJdbcClient).getConnection(any());

        doAnswer(invocation -> {
            Handler<AsyncResult<Void>> closeHandler = invocation.getArgument(0);
            closeHandler.handle(Future.succeededFuture());
            return null;
        }).when(mockSqlConnection).close(any());

        doAnswer(invocation -> {
            Handler<AsyncResult<io.vertx.ext.sql.ResultSet>> queryHandler = invocation.getArgument(1);
            queryHandler.handle(Future.succeededFuture());
            return null;
        }).when(mockSqlConnection).query(eq("SELECT 1"), any());

        verticle.handle(mockMessage);

        verify(mockMessage).reply(argThat(response -> {
            JsonObject jsonResponse = (JsonObject) response;
            return "Success".equals(jsonResponse.getString("connection-status")) &&
                   "Success".equals(jsonResponse.getString("query-run-status"));
        }));
    }

    @Test
    public void testHandle_FailedQuery() {
        JsonObject requestBody = new JsonObject()
                .put("sqlQuery", "SELECT 1")
                .put("dbConfig", new JsonObject().put("url", "jdbc:test"));

        MultiMap headers = MultiMap.caseInsensitiveMultiMap();
        when(mockMessage.body()).thenReturn(requestBody);
        when(mockMessage.headers()).thenReturn(headers);

        MessageMarker mockMessageMarker = mock(MessageMarker.class);
        when(MessageMarker.getMessageMarker(headers)).thenReturn(mockMessageMarker);

        when(JDBCClient.createShared(mockVertx, requestBody.getJsonObject("dbConfig"))).thenReturn(mockJdbcClient);

        doAnswer(invocation -> {
            Handler<AsyncResult<SQLConnection>> handler = invocation.getArgument(0);
            handler.handle(Future.succeededFuture(mockSqlConnection));
            return null;
        }).when(mockJdbcClient).getConnection(any());

        doAnswer(invocation -> {
            Handler<AsyncResult<Void>> closeHandler = invocation.getArgument(0);
            closeHandler.handle(Future.succeededFuture());
            return null;
        }).when(mockSqlConnection).close(any());

        doAnswer(invocation -> {
            Handler<AsyncResult<io.vertx.ext.sql.ResultSet>> queryHandler = invocation.getArgument(1);
            queryHandler.handle(Future.failedFuture(new RuntimeException("Query failed")));
            return null;
        }).when(mockSqlConnection).query(eq("SELECT 1"), any());

        verticle.handle(mockMessage);

        verify(mockMessage).reply(argThat(response -> {
            JsonObject jsonResponse = (JsonObject) response;
            return "Success".equals(jsonResponse.getString("connection-status")) &&
                   "Failure".equals(jsonResponse.getString("query-run-status"));
        }));
    }

    @Test
    public void testHandle_ConnectionFailed() {
        JsonObject requestBody = new JsonObject()
                .put("sqlQuery", "SELECT 1")
                .put("dbConfig", new JsonObject().put("url", "jdbc:test"));

        MultiMap headers = MultiMap.caseInsensitiveMultiMap();
        when(mockMessage.body()).thenReturn(requestBody);
        when(mockMessage.headers()).thenReturn(headers);

        MessageMarker mockMessageMarker = mock(MessageMarker.class);
        when(MessageMarker.getMessageMarker(headers)).thenReturn(mockMessageMarker);

        when(JDBCClient.createShared(mockVertx, requestBody.getJsonObject("dbConfig"))).thenReturn(mockJdbcClient);

        doAnswer(invocation -> {
            Handler<AsyncResult<SQLConnection>> handler = invocation.getArgument(0);
            handler.handle(Future.failedFuture(new RuntimeException("Connection failed")));
            return null;
        }).when(mockJdbcClient).getConnection(any());

        verticle.handle(mockMessage);

        verify(mockMessage).reply(argThat(response -> {
            JsonObject jsonResponse = (JsonObject) response;
            return "Failure".equals(jsonResponse.getString("connection-status")) &&
                   "".equals(jsonResponse.getString("query-run-status"));
        }));
    }
}
